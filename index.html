<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stream Zone Movies Admin Panel</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        :root {
            --primary-bg: #0b0f30;
            --secondary-bg: #121740;
            --accent-color: #d1e231;
            --text-color: #ffffff;
            --gradient-start: #ff006b;
            --gradient-mid: #FF9800;
            --gradient-end: #FFEB3B;
            --danger-color: #f44336;
            --success-color: #4CAF50;
            --info-color: #2196F3;
            --warn-color: #f39c12;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: Arial, sans-serif; background-color: var(--primary-bg); color: var(--text-color); display: flex; min-height: 100vh; overflow-x: hidden; flex-direction: column; } /* Adjusted to min-height and overflow-x hidden */

        /* Main Menu / Sidebar */
        #mainMenu {
            position: fixed; /* Keep fixed */
            top: 0;
            left: -260px; /* Default closed state */
            width: 250px;
            height: 100%;
            background-color: var(--secondary-bg);
            padding-top: 60px;
            transition: left 0.3s ease-in-out;
            z-index: 1100;
            border-right: 2px solid var(--accent-color);
            box-shadow: 5px 0 15px rgba(0,0,0,0.2);
        }
        #mainMenu.open { left: 0; } /* Open state */
        #mainMenu .menu-header { color: var(--accent-color); padding: 10px 20px; font-size: 1.5em; text-align: center; border-bottom: 1px solid #333; margin-bottom: 20px; }
        #mainMenu a { padding: 15px 20px; text-decoration: none; font-size: 18px; color: var(--text-color); display: flex; align-items: center; gap: 15px; transition: background-color 0.2s, color 0.2s; cursor: pointer; }
        #mainMenu a:hover { background-color: var(--primary-bg); }
        #mainMenu a.active { background-color: var(--accent-color); color: var(--primary-bg); font-weight: bold; }

        /* Menu Toggle Button */
        #menuToggleBtn {
            position: fixed;
            top: 15px; /* Adjusted for better visibility */
            left: 15px; /* Adjusted for better visibility */
            background: var(--secondary-bg);
            color: var(--accent-color);
            border: 1px solid var(--accent-color);
            border-radius: 5px;
            width: 50px;
            height: 50px;
            cursor: pointer;
            z-index: 1200;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        #menuToggleBtn:hover { background-color: var(--primary-bg); }

        /* Main Content Area */
        .main-content {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto;
            min-height: 100vh; /* Ensure it takes full height */
            transition: margin-left 0.3s ease-in-out;
            width: 100%;
            margin-left: 0; /* Default for closed menu/mobile */
        }

        /* Login Container */
        .login-container {
            background-color: var(--secondary-bg);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 400px;
            margin: 50px auto;
            text-align: center;
        }

        /* Page Containers */
        .page-container {
            display: none;
            background-color: var(--secondary-bg);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 800px;
            margin: 20px auto;
        }
        .page-container.active { display: block; }

        h1, h2 { text-align: center; color: var(--accent-color); margin-bottom: 20px; }

        /* Admin Header (Top bar) */
        .admin-header {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 10px 0;
            gap: 10px;
        }

        /* Logged in user email display */
        #adminEmailDisplay {
            font-size: 0.9em;
            color: #aaa;
            font-weight: normal;
            text-align: center;
            width: 100%;
            order: 3;
        }

        /* Logout Button */
        .logout-btn {
            background: var(--danger-color);
            width: auto;
            padding: 10px 15px;
            font-size: 14px;
            order: 2;
        }

        /* Form elements */
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 8px; font-weight: bold; }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 12px; border: 1px solid #333; border-radius: 5px; background-color: var(--primary-bg); color: var(--text-color); font-size: 16px; }
        .form-group input[readonly] { background-color: #2a2f50; cursor: not-allowed; opacity: 0.7; }
        .form-group input:focus, .form-group select:focus, .form-group textarea:focus { outline: none; border-color: var(--accent-color); }
        button { display: inline-block; width: 100%; padding: 15px; background: linear-gradient(45deg, var(--gradient-start), var(--gradient-mid), var(--gradient-end)); color: var(--text-color); border: none; border-radius: 5px; font-size: 18px; cursor: pointer; transition: transform 0.2s ease, opacity 0.2s; margin-top: 10px; position: relative; text-align: center; }
        button:hover { transform: translateY(-2px); opacity: 0.9; }
        button.loading { color: transparent !important; pointer-events: none; }
        button .spinner { display: none; border: 4px solid rgba(255, 255, 255, 0.3); border-top: 4px solid white; border-radius: 50%; width: 18px; height: 18px; animation: spin 1s linear infinite; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); }
        button.loading .spinner { display: block; }
        @keyframes spin { 0% { transform: translate(-50%, -50%) rotate(0deg); } 100% { transform: translate(-50%, -50%) rotate(360deg); } }
        .checkbox-group { display: flex; flex-wrap: wrap; gap: 10px 20px; background-color: var(--primary-bg); padding: 15px; border-radius: 5px; border: 1px solid #333; }
        .checkbox-group label { display: flex; align-items: center; gap: 8px; cursor: pointer; font-weight: normal; }
        .checkbox-group input[type="checkbox"] { height: 18px; width: 18px; cursor: pointer; }
        .message { margin-top: 20px; padding: 12px; border-radius: 5px; text-align: center; display: none; }
        .message.success { background-color: var(--success-color); }
        .message.error { background-color: var(--danger-color); }
        .message.info { background-color: var(--info-color); }
        .message.warn { background-color: var(--warn-color); } /* Added for warnings */
        .result-item { background-color: var(--primary-bg); padding: 10px; margin-bottom: 5px; border-radius: 5px; display: flex; flex-direction: column; align-items: flex-start; justify-content: space-between; gap: 10px; }
        .result-item span { text-align: left; width: 100%; }
        .result-item-actions { display: flex; flex-wrap: wrap; gap: 8px; width: 100%; justify-content: flex-start; }
        .action-btn { background-color: var(--accent-color) !important; color: var(--primary-bg) !important; padding: 8px 12px !important; border-radius: 5px !important; width: auto !important; font-size: 14px !important; margin-top: 0 !important; flex-grow: 1; min-width: 80px; }
        .action-btn.edit { background-color: var(--warn-color) !important; color: white !important; }
        .action-btn.delete { background-color: var(--danger-color) !important; color: white !important; }
        .action-btn.select-delete.selected { background-color: var(--success-color) !important; color: white !important; }
        .banner-nav-tabs { display: flex; flex-wrap: wrap; border-bottom: 1px solid var(--accent-color); margin-bottom: 20px; }
        .banner-tab-link { padding: 10px 15px; cursor: pointer; color: #aaa; border: none; background: none; font-size: 15px; flex-grow: 1; text-align: center; }
        .banner-tab-link.active { color: var(--accent-color); border-bottom: 2px solid var(--accent-color); font-weight: bold; }
        .banner-tab-content { display: none; }
        .banner-tab-content.active { display: block; }
        #allBannersContainer { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-top: 20px; }
        .banner-card { background-color: var(--primary-bg); border-radius: 8px; overflow: hidden; box-shadow: 0 4px 8px rgba(0,0,0,0.3); display: flex; flex-direction: column; }
        .banner-card img { width: 100%; height: 120px; object-fit: cover; background-color: #000; }
        .banner-card-content { padding: 10px; flex-grow: 1; display: flex; flex-direction: column; }
        .banner-card h3 { font-size: 1em; color: var(--accent-color); margin-bottom: 5px; text-align: left; }
        .banner-card p { font-size: 0.8em; color: #ccc; margin-bottom: 10px; flex-grow: 1; line-height: 1.4; }
        .banner-card-actions { display: flex; gap: 8px; margin-top: auto; border-top: 1px solid #333; padding-top: 8px; }
        .banner-card-actions .action-btn { width: 100% !important; flex: 1; }
        .banner-card-actions .action-btn.delete { background-color: var(--danger-color) !important; color: white !important; }

        /* Styles for User Management Section */
        #userManagementPage .input-group { margin-bottom: 15px; }
        #userManagementPage .input-group label { display: block; margin-bottom: 8px; color: #ccc; font-size: 14px; }
        #userManagementPage .input-group input, #userManagementPage .input-group select { width: 100%; padding: 10px; background: #222; border: 1px solid #444; border-radius: 8px; color: white; font-size: 15px; }
        #userManagementPage .btn-secondary { background: #555; }
        #userManagementPage hr { border-color: #444; margin: 20px 0; }

        /* NEW: Styles for All Content Page */
        .movie-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); /* Adjusted for more columns */
            gap: 20px;
            margin-top: 20px;
        }

        .content-card {
            background-color: var(--primary-bg);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            text-align: center;
            position: relative; /* For the checkbox */
        }

        .content-card img {
            width: 100%;
            height: 250px; /* Increased height for better visibility */
            object-fit: cover;
            background-color: #000;
            border-bottom: 1px solid #333;
        }

        .content-card-content {
            padding: 10px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Pushes buttons to bottom */
        }

        .content-card h3 {
            font-size: 1.1em;
            color: var(--accent-color);
            margin-bottom: 5px;
            white-space: nowrap; /* Prevent title from wrapping */
            overflow: hidden;
            text-overflow: ellipsis; /* Add ellipsis for long titles */
            padding: 0 5px; /* Add some padding */
        }

        .content-card p.vj-name {
            font-size: 0.8em;
            color: #ccc;
            margin-bottom: 10px;
            padding: 0 5px;
        }
        .content-card p.content-id-display,
        .content-card p.content-project-display {
            font-size: 0.75em;
            color: #999;
            margin-bottom: 3px;
        }

        .content-card-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px; /* Space from description */
            border-top: 1px solid #333;
            padding-top: 8px;
            justify-content: center; /* Center the buttons */
        }

        .content-card-actions .action-btn {
            flex: 1; /* Make buttons take equal space */
            min-width: unset; /* Override previous min-width */
            font-size: 0.9em !important;
            padding: 6px 10px !important;
        }

        .content-card input[type="checkbox"].select-card-checkbox {
            position: absolute;
            top: 8px;
            left: 8px;
            z-index: 10;
            width: 24px;
            height: 24px;
            cursor: pointer;
            background-color: rgba(0,0,0,0.5);
            border: 2px solid var(--accent-color);
            border-radius: 4px;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        .content-card input[type="checkbox"].select-card-checkbox:checked {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }

        .content-card input[type="checkbox"].select-card-checkbox:checked::before {
            content: '\2713'; /* Checkmark character */
            display: block;
            color: var(--primary-bg);
            font-size: 18px;
            line-height: 20px;
            text-align: center;
        }

        /* Styles for the new "For Sort Page Only" sections */
        .sort-page-section {
            margin-top: 30px;
            border-top: 1px solid #555;
            padding-top: 20px;
        }
        .sort-page-section h3 {
            color: var(--accent-color);
            margin-bottom: 15px;
            text-align: left;
        }

        /* --- Media Queries for Responsiveness --- */
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            #mainMenu {
                left: -260px; /* Keep it off-screen by default on small screens */
                width: 250px;
                padding-top: 80px; /* Make space for toggle button */
            }
            /* .open class will apply `left: 0` */

            #menuToggleBtn {
                position: fixed;
                top: 15px;
                left: 15px;
            }

            .main-content {
                margin-left: 0; /* No margin on small screens when menu is closed */
                padding: 15px;
                margin-top: 60px; /* Space for the fixed toggle button */
            }

            /* Adjust admin header for small screens */
            .admin-header {
                flex-direction: column;
                align-items: flex-start;
                margin-top: 0; /* Remove extra top margin as main-content now handles it */
            }
            #pageTitle {
                width: 100%;
                text-align: left;
                font-size: 1.8em;
                margin-bottom: 10px;
                order: 1;
            }
            #adminEmailDisplay {
                width: 100%;
                text-align: left;
                font-size: 0.8em;
                margin-bottom: 10px;
                order: 3;
            }
            .logout-btn {
                width: auto;
                order: 2;
                margin-left: auto;
                margin-top: -40px; /* Pull it up to sit next to the title if space allows */
            }

            .page-container {
                padding: 15px;
                margin: 15px auto;
            }

            .result-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            .result-item-actions {
                flex-direction: column;
                width: 100%;
            }
            .action-btn {
                width: 100% !important;
            }

            #allBannersContainer {
                grid-template-columns: 1fr;
            }
            .banner-card img {
                height: 100px;
            }
            .banner-card-content {
                padding: 8px;
            }
            .banner-card h3 {
                font-size: 0.9em;
            }
            .banner-card p {
                font-size: 0.75em;
            }
            .banner-tab-link {
                font-size: 14px;
                padding: 8px 10px;
            }

            /* NEW: All Content Page mobile adjustments */
            .movie-grid {
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
                gap: 15px;
            }
            .content-card img {
                height: 200px;
            }
            .content-card h3 {
                font-size: 1em;
            }
            .content-card p.vj-name {
                font-size: 0.7em;
            }
            .content-card-actions .action-btn {
                font-size: 0.8em !important;
                padding: 5px 8px !important;
            }
        }

        /* Desktop adjustments (min-width: 769px) */
        @media (min-width: 769px) {
            body {
                flex-direction: row; /* Main content and menu side-by-side */
            }

            #mainMenu {
                left: 0; /* Default open state on desktop */
                box-shadow: 5px 0 15px rgba(0,0,0,0.2); /* Re-add shadow for fixed menu */
            }

            #menuToggleBtn {
                top: 15px; /* Stay at top */
                left: calc(250px + 15px); /* Positioned relative to the open menu, +15px for spacing */
                transition: left 0.3s ease-in-out; /* Add transition for button too */
            }
            #mainMenu.open + #menuToggleBtn { /* When menu is open, move toggle button */
                left: calc(250px + 15px);
            }
            #mainMenu:not(.open) + #menuToggleBtn { /* When menu is NOT open, move toggle button back */
                left: 15px;
            }


            .main-content {
                margin-left: 250px; /* Space for the open sidebar */
                padding-top: 20px; /* Reset top padding from mobile */
            }

            /* Admin header for desktop */
            .admin-header {
                flex-direction: row;
                align-items: center;
                margin-top: 0;
            }
            #pageTitle {
                text-align: center;
                flex-grow: 1;
                order: initial;
            }
            #adminEmailDisplay {
                font-size: 14px;
                text-align: right;
                width: auto;
                margin-left: 20px;
                order: initial;
            }
            .logout-btn {
                width: auto;
                order: initial;
                margin-left: 15px;
                margin-top: 0;
            }
            
            .result-item {
                flex-direction: row;
                align-items: center;
            }
            .result-item-actions {
                flex-direction: row;
                width: auto;
            }
            .action-btn {
                width: auto !important;
            }
        }
    </style>
</head>
<body>

    <div id="loginScreen" class="main-content">
        <div class="login-container">
            <h1>Admin Login</h1>
            <form id="loginForm">
                <div class="form-group"><label for="loginEmail">Email</label><input type="email" id="loginEmail" required></div>
                <div class="form-group"><label for="loginPassword">Password</label><input type="password" id="loginPassword" required></div>
                <button type="submit">Login<span class="spinner"></span></button>
            </form>
            <div id="loginMessage" class="message"></div>
        </div>
    </div>

    <div id="adminPanel" style="display: none; width: 100%;">
        <button id="menuToggleBtn"><i class="fas fa-bars"></i></button>
<nav id="mainMenu">
    <div class="menu-header">Admin Menu</div>
    <a class="menu-link" data-page="addContentPage"><i class="fas fa-magic"></i> Add from TMDB</a>
    <a class="menu-link" data-page="manualAddPage"><i class="fas fa-edit"></i> Manual Add</a>
    <a class="menu-link" data-page="manageContentPage"><i class="fas fa-search"></i> Search & Edit/Delete</a>
    <a class="menu-link" data-page="allContentPage"><i class="fas fa-film"></i> All Content</a> 
    <a class="menu-link" data-page="bannerPage"><i class="fas fa-images"></i> Manage Banners</a>
    <a class="menu-link" data-page="userManagementPage"><i class="fas fa-users-cog"></i> User Management</a>
    <a class="https://cyber.follow256.com" href="https://cyber.follow256.com"><i class="fas fa-server"></i> My SERVER</a>
</nav>


        <div class="main-content" id="mainContentArea">
            <div class="admin-header">
                <h1 id="pageTitle"></h1>
                <span id="adminEmailDisplay" style="font-weight: normal;"></span>
                <button class="logout-btn" id="logoutBtn">Logout <i class="fas fa-sign-out-alt"></i></button>
            </div>

            <div id="addContentPage" class="page-container">
                <h2>Add Content from TMDB</h2>
                <form id="addMovieForm">
                    <div class="form-group"><label for="tmdbApiKey">TMDB API Key</label><input type="text" id="tmdbApiKey" value="f7a3b097ba7a990fd0c8ef3147646fb5" readonly></div>
                    <div class="form-group"><label for="primaryContentType">Primary Content Type</label><select id="primaryContentType" class="primary-content-type-selector" required><option value="movie">Movie</option><option value="tv">TV Series</option></select></div>
                    <div class="form-group media-categories-group">
                        <label>Categories (Select all that apply)</label>
                        <div class="checkbox-group" id="contentTypeCheckboxes">
                            
                            
                            <label><input type="checkbox" name="contentType" value="latest_uploads"> Latest Uploads</label>
                            <label><input type="checkbox" name="contentType" value="Latest-Movies">Latest Movies</label>
                            <label><input type="checkbox" name="contentType" value="most_liked"> Most Liked</label>
                            <label><input type="checkbox" name="contentType" value="animation"> Animation</label>
                            <label><input type="checkbox" name="contentType" value="indian"> Indian</label>
                            <label><input type="checkbox" name="contentType" value="horror"> Horror</label>
                            <label><input type="checkbox" name="contentType" value="comedy"> Comedy</label>
                            <label><input type="checkbox" name="contentType" value="romance"> Romance</label>
                            <label><input type="checkbox" name="contentType" value="adventure"> Adventure</label>
                            <label><input type="checkbox" name="contentType" value="scifi-fantasy"> Sci-fi & Fantasy</label>
                            <label><input type="checkbox" name="contentType" value="action-thriller"> Action & Thriller</label>
                            <label><input type="checkbox" name="contentType" value="high-school"> High School</label>
                            <label><input type="checkbox" name="contentType" value="nigerian"> Nigerian Movies</label>
                            <label><input type="checkbox" name="contentType" value="upcoming_shows"> Upcoming Shows</label>
                            <label><input type="checkbox" name="contentType" value="western_series"> Western Series</label>
                            <label><input type="checkbox" name="contentType" value="Latest-TV-Series"> Latest Tv Shows</label>
                            <label><input type="checkbox" name="contentType" value="k_dramas"> K Dramas</label>
                        </div>
                    </div>
                    <div class="form-group"><label for="contentIdentifier">Content Name or TMDB ID</label><input type="text" id="contentIdentifier" placeholder="e.g., The Matrix or TMDB ID 603" required></div>
                    <div class="form-group"><label for="vjName">VJ Name</label><input type="text" id="vjName" required></div>
                    <div class="form-group video-url-group"><label for="videoSourceUrl">Video Source URL</label><input type="url" id="videoSourceUrl" placeholder="e.g., https://example.com/video.mp4"></div>
                    <div class="form-group series-data-group" style="display: none;"><label for="seriesData">Series Data (JSON)</label><textarea id="seriesData" rows="8"></textarea></div>
                    
                    <hr class="sort-page-section" />
                    <div class="sort-page-section">
                        <h3>For Sort Page Only</h3>
                        <div class="form-group">
                            <label>VJs for Sort Page</label>
                            <div class="checkbox-group" id="sortVjsCheckboxesTMDB">
                                </div>
                        </div>
                        <div class="form-group">
                            <label>Genres for Sort Page</label>
                            <div class="checkbox-group" id="sortGenresCheckboxesTMDB">
                                </div>
                        </div>
                    </div>
                    <button type="submit" id="addContentBtn">Add Content<span class="spinner"></span></button>
                </form>
                <div id="addMessage" class="message"></div>
            </div>

            <div id="manualAddPage" class="page-container">
                <h2>Manually Add Content</h2>
                <form id="manualAddForm">
                    <div class="form-group"><label for="manualTitle">Title</label><input type="text" id="manualTitle" required></div>
                    <div class="form-group"><label for="manualOverview">Overview</label><textarea id="manualOverview" rows="4" required></textarea></div>
                    <div class="form-group"><label for="manualPosterUrl">Poster Image URL</label><input type="url" id="manualPosterUrl" required></div>
                    <div class="form-group"><label for="manualBackdropUrl">Backdrop Image URL</label><input type="url" id="manualBackdropUrl"></div>
                    <div class="form-group"><label for="manualVjName">VJ Name</label><input type="text" id="manualVjName" required></div>
                    <div class="form-group"><label for="manualPrimaryContentType">Primary Content Type</label><select id="manualPrimaryContentType" class="primary-content-type-selector" required><option value="movie">Movie</option><option value="tv">TV Series</option></select></div>
                    <div class="form-group media-categories-group">
                        <label>Categories</label>
                        <div class="checkbox-group" id="manualContentTypeCheckboxes">
                            
                            
                            <label><input type="checkbox" name="manualContentType" value="latest_uploads"> Latest Uploads</label>
                            <label><input type="checkbox" name="manualContentType" value="Latest-Movies">Latest Movies</label>
                            <label><input type="checkbox" name="manualContentType" value="most_liked"> Most Liked</label>
                            <label><input type="checkbox" name="manualContentType" value="animation"> Animation</label>
                            <label><input type="checkbox" name="manualContentType" value="indian"> Indian</label>
                            <label><input type="checkbox" name="manualContentType" value="horror"> Horror</label>
                            <label><input type="checkbox" name="manualContentType" value="comedy"> Comedy</label>
                            <label><input type="checkbox" name="manualContentType" value="romance"> Romance</label>
                            <label><input type="checkbox" name="manualContentType" value="adventure"> Adventure</label>
                            <label><input type="checkbox" name="manualContentType" value="scifi-fantasy"> Sci-fi & Fantasy</label>
                            <label><input type="checkbox" name="manualContentType" value="action-thriller"> Action & Thriller</label>
                            <label><input type="checkbox" name="manualContentType" value="high-school"> High School</label>
                            <label><input type="checkbox" name="manualContentType" value="nigerian"> Nigerian Movies</label>
                            <label><input type="checkbox" name="manualContentType" value="upcoming_shows"> Upcoming Shows</label>
                            <label><input type="checkbox" name="manualContentType" value="western_series"> Western Series</label>
                            <label><input type="checkbox" name="manualContentType" value="Latest-TV-Series">Latest Tv shows</label>
                            <label><input type="checkbox" name="manualContentType" value="k_dramas"> K Dramas</label>
                        </div>
                    </div>

                    <div class="form-group genre-selection-group">
                        <label>Genres (Select all that apply)</label>
                        <div class="checkbox-group" id="manualGenreCheckboxes">
                            <label><input type="checkbox" name="manualGenre" value="action"> Action</label>
                            <label><input type="checkbox" name="manualGenre" value="adventure"> Adventure</label>
                            <label><input type="checkbox" name="manualGenre" value="animation"> Animation</label>
                            <label><input type="checkbox" name="manualGenre" value="comedy"> Comedy</label>
                            <label><input type="checkbox" name="manualGenre" value="crime"> Crime</label>
                            <label><input type="checkbox" name="manualGenre" value="documentary"> Documentary</label>
                            <label><input type="checkbox" name="manualGenre" value="drama"> Drama</label>
                            <label><input type="checkbox" name="manualGenre" value="family"> Family</label>
                            <label><input type="checkbox" name="manualGenre" value="fantasy"> Fantasy</label>
                            <label><input type="checkbox" name="manualGenre" value="history"> History</label>
                            <label><input type="checkbox" name="manualGenre" value="horror"> Horror</label>
                            <label><input type="checkbox" name="manualGenre" value="music"> Music</label>
                            <label><input type="checkbox" name="manualGenre" value="mystery"> Mystery</label>
                            <label><input type="checkbox" name="manualGenre" value="romance"> Romance</label>
                            <label><input type="checkbox" name="manualGenre" value="science-fiction"> Science Fiction</label>
                            <label><input type="checkbox" name="manualGenre" value="tv-movie"> TV Movie</label>
                            <label><input type="checkbox" name="manualGenre" value="thriller"> Thriller</label>
                            <label><input type="checkbox" name="manualGenre" value="war"> War</label>
                            <label><input type="checkbox" name="manualGenre" value="western"> Western</label>
                        </div>
                    </div>
                    <div class="form-group"><label for="manualReferenceId">Unique Text ID (e.g., mercy-for-none)</label><input type="text" id="manualReferenceId" placeholder="Enter a unique text identifier" required></div>

                    <div class="form-group video-url-group"><label for="manualVideoSourceUrl">Video Source URL</label><input type="url" id="manualVideoSourceUrl"></div>
                    <div class="form-group series-data-group" style="display: none;"><label for="manualSeriesData">Series Data (JSON)</label><textarea id="manualSeriesData" rows="8"></textarea></div>

                    <hr class="sort-page-section" />
                    <div class="sort-page-section">
                        <h3>For Sort Page Only</h3>
                        <div class="form-group">
                            <label>VJs for Sort Page</label>
                            <div class="checkbox-group" id="sortVjsCheckboxesManual">
                                </div>
                        </div>
                        <div class="form-group">
                            <label>Genres for Sort Page</label>
                            <div class="checkbox-group" id="sortGenresCheckboxesManual">
                                </div>
                        </div>
                    </div>
                    <button type="submit" id="manualAddContentBtn">Add Manually<span class="spinner"></span></button>
                </form>
                <div id="manualAddMessage" class="message"></div>
            </div>

            <div id="manageContentPage" class="page-container">
                <h2>Search & Manage Content</h2>
                <form id="manageContentForm">
                    <div class="form-group">
                        <label for="manageContentIdentifier">Search by Content Name, TMDB ID or Unique Text ID</label>
                        <input type="text" id="manageContentIdentifier" required>
                    </div>
                    <button type="button" id="searchManageBtn">Search Content<span class="spinner"></span></button>
                </form>
                <div id="manageSearchResults" style="margin-top: 20px;"></div>
                <button type="button" id="confirmDeleteBtn" style="display: none; background-color: var(--danger-color);">Delete Selected Content<span class="spinner"></span></button>
                <div id="manageMessage" class="message"></div>
            </div>

            <div id="allContentPage" class="page-container">
                <h2>All Available Content</h2>
                <div class="form-group">
                    <label for="allContentFilter">Filter by Category:</label>
                    <select id="allContentFilter">
                        <option value="all">All</option>
            
                        <option value="latest_uploads">Latest Uploads</option>
                        <option value="Latest-Movies">Latest Movies</option>
                        <option value="most_liked">Most Liked</option>
                        <option value="animation">Animation</option>
                        <option value="indian">Indian</option>
                        <option value="horror">Horror</option>
                        <option value="comedy">Comedy</option>
                        <option value="romance">Romance</option>
                        <option value="adventure">Adventure</option>
                        <option value="scifi-fantasy">Sci-fi & Fantasy</option>
                        <option value="action-thriller">Action & Thriller</option>
                        <option value="high-school">High School</option>
                        <option value="nigerian">Nigerian Movies</option>
                        <option value="upcoming_shows">Upcoming Shows</option>
                        <option value="western_series">Western Series</option>
                        <option value="Latest-TV-Series">Latest Tv Shows</option>
                        <option value="k_dramas">K Dramas</option>
                    </select>
                </div>
                <div id="allContentContainer" class="movie-grid"></div>
                <button type="button" id="deleteSelectedAllContentBtn" style="display: none; background-color: var(--danger-color); margin-top: 20px;">Delete Selected Content (<span id="selectedAllContentCount">0</span>)<span class="spinner"></span></button>
                <div id="allContentMessage" class="message"></div>
            </div>

            <div id="editContentPage" class="page-container">
                <h2>Edit Content</h2>
                <form id="editContentForm">
                    <input type="hidden" id="editDocId">
                    <div class="form-group"><label for="editTitle">Title</label><input type="text" id="editTitle" required></div>
                    <div class="form-group"><label for="editOverview">Overview</label><textarea id="editOverview" rows="4" required></textarea></div>
                    <div class="form-group"><label for="editPosterUrl">Poster Image URL</label><input type="url" id="editPosterUrl" required></div>
                    <div class="form-group"><label for="editBackdropUrl">Backdrop Image URL</label><input type="url" id="editBackdropUrl"></div>
                    <div class="form-group"><label for="editVjName">VJ Name</label><input type="text" id="editVjName" required></div>
                    <div class="form-group"><label for="editPrimaryContentType">Primary Content Type</label><select id="editPrimaryContentType" class="primary-content-type-selector" required><option value="movie">Movie</option><option value="tv">TV Series</option></select></div>
                    <div class="form-group media-categories-group">
                        <label>Categories</label>
                        <div class="checkbox-group" id="editContentTypeCheckboxes">
                            
                            
                            <label><input type="checkbox" name="editContentType" value="latest_uploads"> Latest Uploads</label>
                            <label><input type="checkbox" name="editContentType" value="Latest-Movies">Latest Movies</label>
                            <label><input type="checkbox" name="editContentType" value="most_liked"> Most Liked</label>
                            <label><input type="checkbox" name="editContentType" value="animation"> Animation</label>
                            <label><input type="checkbox" name="editContentType" value="indian"> Indian</label>
                            <label><input type="checkbox" name="editContentType" value="horror"> Horror</label>
                            <label><input type="checkbox" name="editContentType" value="comedy"> Comedy</label>
                            <label><input type="checkbox" name="editContentType" value="romance"> Romance</label>
                            <label><input type="checkbox" name="editContentType" value="adventure"> Adventure</label>
                            <label><input type="checkbox" name="editContentType" value="scifi-fantasy"> Sci-fi & Fantasy</label>
                            <label><input type="checkbox" name="editContentType" value="action-thriller"> Action & Thriller</label>
                            <label><input type="checkbox" name="editContentType" value="high-school"> High School</label>
                            <label><input type="checkbox" name="editContentType" value="nigerian"> Nigerian Movies</label>
                            <label><input type="checkbox" name="editContentType" value="upcoming_shows"> Upcoming Shows</label>
                            <label><input type="checkbox" name="editContentType" value="western_series"> Western Series</label>
                            <label><input type="checkbox" name="editContentType" value="Latest-TV-Series"> Latest Tv shows</label>
                            <label><input type="checkbox" name="editContentType" value="k_dramas"> K Dramas</label>
                        </div>
                    </div>

                    <div class="form-group genre-selection-group">
                        <label>Genres (Select all that apply)</label>
                        <div class="checkbox-group" id="editGenreCheckboxes">
                            <label><input type="checkbox" name="editGenre" value="action"> Action</label>
                            <label><input type="checkbox" name="editGenre" value="adventure"> Adventure</label>
                            <label><input type="checkbox" name="editGenre" value="animation"> Animation</label>
                            <label><input type="checkbox" name="editGenre" value="comedy"> Comedy</label>
                            <label><input type="checkbox" name="editGenre" value="crime"> Crime</label>
                            <label><input type="checkbox" name="editGenre" value="documentary"> Documentary</label>
                            <label><input type="checkbox" name="editGenre" value="drama"> Drama</label>
                            <label><input type="checkbox" name="genre" value="family"> Family</label>
                            <label><input type="checkbox" name="editGenre" value="fantasy"> Fantasy</label>
                            <label><input type="checkbox" name="editGenre" value="history"> History</label>
                            <label><input type="checkbox" name="editGenre" value="horror"> Horror</label>
                            <label><input type="checkbox" name="editGenre" value="music"> Music</label>
                            <label><input type="checkbox" name="editGenre" value="mystery"> Mystery</label>
                            <label><input type="checkbox" name="editGenre" value="romance"> Romance</label>
                            <label><input type="checkbox" name="editGenre" value="science-fiction"> Science Fiction</label>
                            <label><input type="checkbox" name="editGenre" value="tv-movie"> TV Movie</label>
                            <label><input type="checkbox" name="editGenre" value="thriller"> Thriller</label>
                            <label><input type="checkbox" name="editGenre" value="war"> War</label>
                            <label><input type="checkbox" name="editGenre" value="western"> Western</label>
                        </div>
                    </div>
                    <div class="form-group"><label for="editReferenceId">Reference ID (TMDB or Custom Text)</label><input type="text" id="editReferenceId" placeholder="TMDB ID or your unique text ID"></div>

                    <div class="form-group video-url-group"><label for="editVideoSourceUrl">Video Source URL</label><input type="url" id="editVideoSourceUrl"></div>
                    <div class="form-group series-data-group" style="display: none;"><label for="editSeriesData">Series Data (JSON)</label><textarea id="editSeriesData" rows="8"></textarea></div>

                    <hr class="sort-page-section" />
                    <div class="sort-page-section">
                        <h3>For Sort Page Only</h3>
                        <div class="form-group">
                            <label>VJs for Sort Page</label>
                            <div class="checkbox-group" id="sortVjsCheckboxesEdit">
                                </div>
                        </div>
                        <div class="form-group">
                            <label>Genres for Sort Page</label>
                            <div class="checkbox-group" id="sortGenresCheckboxesEdit">
                                </div>
                        </div>
                    </div>
                    <button type="submit" id="updateContentBtn">Update Content<span class="spinner"></span></button>
                    <button type="button" id="cancelEditBtn" style="background-color: gray; margin-top: 10px;">Cancel Edit</button>
                </form>
                <div id="editMessage" class="message"></div>
            </div>

            <div id="bannerPage" class="page-container">
                <div class="banner-nav-tabs">
                    <button class="banner-tab-link" data-tab="viewBannersTab">View All Banners</button>
                    <button class="banner-tab-link" data-tab="addBannerTab">Add/Edit Banner</button>
                </div>
                
                <div id="addBannerTab" class="banner-tab-content">
                    <h2 id="bannerFormTitle">Add New Banner</h2>
                    <form id="addEditBannerForm">
                        <input type="hidden" id="bannerDocId">
                        <div class="form-group"><label for="bannerTitle">Banner Title</label><input type="text" id="bannerTitle" required></div>
                        <div class="form-group"><label for="bannerImageUrl">Image URL</label><input type="text" id="bannerImageUrl" required></div>
                        <div class="form-group"><label for="bannerDescription">Description</label><textarea id="bannerDescription" rows="3"></textarea></div>
                        <div class="form-group"><label for="bannerLink">"Watch Now" Link</label><input type="text" id="bannerLink" required></div>
                        <button type="submit" id="saveBannerBtn">Save Banner<span class="spinner"></span></button>
                        <button type="button" id="cancelEditBannerBtn" style="display:none; background: gray;">Cancel Edit / New</button>
                    </form>
                    <div id="addBannerMessage" class="message"></div>
                </div>

                <div id="viewBannersTab" class="banner-tab-content">
                    <h2>All Available Banners</h2>
                    <div id="allBannersContainer"></div>
                    <div id="viewBannersMessage" class="message"></div>
                </div>
            </div>

            <div id="userManagementPage" class="page-container">
                <h2>User Management Panel</h2>
                
                <div class="input-group">
                    <label for="user-search-email">Search User by Email</label>
                    <input type="email" id="user-search-email" placeholder="user@example.com" />
                </div>
                <button class="btn" id="user-search-btn">Search User</button>

                <div id="user-message-area" class="message hidden"></div>
                <hr class="hidden" id="user-form-divider" />

                <div id="user-edit-form-section" class="hidden">
                    <h3 id="user-form-title">Edit User</h3>
                    <div class="input-group"><label for="user-doc-id">Document ID (User UID)</label><input type="text" id="user-doc-id" disabled /></div>
                    <div class="input-group"><label for="user-edit-name">Full Name</label><input type="text" id="user-edit-name" /></div>
                    <div class="input-group"><label for="user-edit-email">Email</label><input type="email" id="user-edit-email" /></div>
                    <div class="input-group"><label for="user-edit-activated">Account Activated</label><select id="user-edit-activated"><option value="true">True</option><option value="false">False</option></select></div>
                    <div class="input-group"><label for="user-edit-expiresAt">Subscription Expiration</label><input type="datetime-local" id="user-edit-expiresAt" /></div>
                    <button class="btn" id="user-update-btn">Update Document</button>
                    <button class="btn btn-secondary" id="user-create-btn">Create New Document</button>
                </div>
            </div>

        </div>
    </div>
    
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
    
   <script>
    document.addEventListener('DOMContentLoaded', () => {
    // --- Firebase Configuration ---
    const firebaseConfig = {
        apiKey: "AIzaSyAn2vbkT9yjyWtJzNSHgRureco5gEjYd_Q",
        authDomain: "stream-zone-movies-a83c1.firebaseapp.com",
        projectId: "stream-zone-movies-a83c1",
        storageBucket: "stream-zone-movies-a83c1.appspot.com",
        messagingSenderId: "148342664213",
        appId: "1:148342664213:web:56df2549cc480df7cf721c"
    };

    // --- Initialize Firebase App ---
    const app = firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore(app);
    const auth = firebase.auth(app);
    
    // --- DOM Element References ---
    const loginScreen = document.getElementById('loginScreen');
    const adminPanel = document.getElementById('adminPanel');
    const mainMenu = document.getElementById('mainMenu');
    const menuToggleBtn = document.getElementById('menuToggleBtn');
    const pageTitle = document.getElementById('pageTitle');
    const adminEmailDisplay = document.getElementById('adminEmailDisplay'); 
    const logoutBtn = document.getElementById('logoutBtn');
    const loginMessage = document.getElementById('loginMessage');
    const mainContentArea = document.getElementById('mainContentArea'); 

    // Content Management Elements
    const addMovieForm = document.getElementById('addMovieForm');
    const addContentBtn = document.getElementById('addContentBtn');
    const addMessage = document.getElementById('addMessage');
    const manualAddForm = document.getElementById('manualAddForm');
    const manualAddBtn = document.getElementById('manualAddContentBtn');
    const manualAddMessage = document.getElementById('manualAddMessage');
    const searchManageBtn = document.getElementById('searchManageBtn');
    const manageSearchResults = document.getElementById('manageSearchResults');
    const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');
    const manageMessage = document.getElementById('manageMessage');
    const editContentForm = document.getElementById('editContentForm');
    const updateContentBtn = document.getElementById('updateContentBtn');
    const editMessage = document.getElementById('editMessage');
    const cancelEditBtn = document.getElementById('cancelEditBtn');

    // Banner Management Elements
    const bannerNavTabs = document.querySelector('.banner-nav-tabs');
    const addEditBannerForm = document.getElementById('addEditBannerForm');
    const bannerFormTitle = document.getElementById('bannerFormTitle');
    const bannerDocId = document.getElementById('bannerDocId');
    const saveBannerBtn = document.getElementById('saveBannerBtn');
    const cancelEditBannerBtn = document.getElementById('cancelEditBannerBtn');
    const addBannerMessage = document.getElementById('addBannerMessage');
    const allBannersContainer = document.getElementById('allBannersContainer');
    const viewBannersMessage = document.getElementById('viewBannersMessage');
    let selectedMoviesForDeletion = new Set(); // For manageContentPage search results

    // User Management Elements
    const userSearchEmailInput = document.getElementById('user-search-email');
    const userSearchBtn = document.getElementById('user-search-btn');
    const userMessageArea = document.getElementById('user-message-area');
    const userEditFormSection = document.getElementById('user-edit-form-section');
    const userFormDivider = document.getElementById('user-form-divider');
    const userDocIdInput = document.getElementById('user-doc-id');
    const userEditNameInput = document.getElementById('user-edit-name');
    const userEditEmailInput = document.getElementById('user-edit-email');
    const userEditActivatedSelect = document.getElementById('user-edit-activated');
    const userEditExpiresAtInput = document.getElementById('user-edit-expiresAt');
    const userUpdateBtn = document.getElementById('user-update-btn');
    const userCreateBtn = document.getElementById('user-create-btn');
    const userFormTitle = document.getElementById('user-form-title'); 

    // All Content Page Elements
    const allContentContainer = document.getElementById('allContentContainer');
    const allContentMessage = document.getElementById('allContentMessage');
    const allContentFilter = document.getElementById('allContentFilter');
    const deleteSelectedAllContentBtn = document.getElementById('deleteSelectedAllContentBtn');
    const selectedAllContentCount = document.getElementById('selectedAllContentCount');
    let selectedAllContentForDeletion = new Set();

    // NEW: VJ and Genre Lists for Sort Page
    const VJ_LIST = [
        "Vj Junior","Vj TONNY", "Vj Emmy", "VJ NEIL", "Vj Jovan","Vj SHIELD","Vj Tom", "Vj Shao Khan", "Vj Jingo", "Vj Ice P", "Vj Kevo",
        "Vj Kevin","Vj SOUL", "Vj Kriss Sweet", "Vj Hd", "Vj Dan De", "Vj Sammy", "Vj Ivo", "Vj Isma K", "Vj Little T", "Vj Mox",
        "Vj Muba", "Vj Eddy", "Vj Kam", "Vj Lance", "Vj KS", "Vj Ulio", "Vj Aaron", "Vj Cabs", "Vj Banks", "Vj Jimmy",
        "Vj Baros","Vj SON", "Vj Kimuli", "Vj Fredy", "Vj Jumpers", "Vj Ashim", "Vj Pauleta", "Vj Martin K", "Vj Henrico", "Vj Uncle T","Vj RONAGE"
    ];
    const GENRE_LIST = [
        "Action", "Horror", "Series", "Adventure", "Love Story", "Comedy", "Crime", "Family", "Sci FI", "Romance",
        "Kungu Fu", "Drama", "Sport", "Thriller", "Animation", "Documentary", "Fantasy", "History", "Music", "Mystery",
        "War", "Western"
    ];

    // Function to populate checkbox groups
    function populateCheckboxes(containerId, namePrefix, list, selectedValues = []) {
        const container = document.getElementById(containerId);
        if (!container) return; // Ensure container exists
        container.innerHTML = ''; // Clear existing checkboxes

        list.forEach(item => {
            const label = document.createElement('label');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.name = namePrefix;
            checkbox.value = item;
            // Ensure selectedValues is treated as an array even if it's null/undefined
            checkbox.checked = Array.isArray(selectedValues) && selectedValues.includes(item); 

            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(` ${item}`));
            container.appendChild(label);
        });
    }

    // Populate all sort page checkbox groups on DOMContentLoaded
    populateCheckboxes('sortVjsCheckboxesTMDB', 'sortVjsTMDB', VJ_LIST);
    populateCheckboxes('sortGenresCheckboxesTMDB', 'sortGenresTMDB', GENRE_LIST);
    populateCheckboxes('sortVjsCheckboxesManual', 'sortVjsManual', VJ_LIST);
    populateCheckboxes('sortGenresCheckboxesManual', 'sortGenresManual', GENRE_LIST);
    // These will be populated by loadContentForEditing when needed
    // populateCheckboxes('sortVjsCheckboxesEdit', 'sortVjsEdit', VJ_LIST); 
    // populateCheckboxes('sortGenresCheckboxesEdit', 'sortGenresEdit', GENRE_LIST);


    // --- Helper Functions ---
    function setLoading(button, isLoading) {
        if(button) {
            button.classList.toggle('loading', isLoading);
            button.disabled = isLoading;
        }
    }

    function displayMessage(element, msg, type) {
        if (element) {
            element.textContent = msg;
            element.className = `message ${type}`;
            element.style.display = 'block';
            setTimeout(() => { element.style.display = 'none'; }, 8000);
        }
    }
    
    function generateSlug(text) {
        if (!text) return '';
        return text
            .toString()
            .toLowerCase()
            .trim()
            .replace(/\s+/g, '-')
            .replace(/[^\w\-]+/g, '')
            .replace(/\-\-+/g, '-');
    }

    async function checkForDuplicates(payload, excludeDocId = null) {
        // Check for duplicate TMDB ID if it exists and is a number
        if (payload.tmdbId && typeof payload.tmdbId === 'number') {
            const q = db.collection('movies').where('tmdbId', '==', payload.tmdbId);
            const snapshot = await q.get();
            for (const doc of snapshot.docs) {
                if (doc.id !== excludeDocId) {
                    return { found: true, field: 'TMDB ID' };
                }
            }
        }

        // Check for duplicate slug
        if (payload.slug) {
            const q = db.collection('movies').where('slug', '==', payload.slug);
            const snapshot = await q.get();
            for (const doc of snapshot.docs) {
                if (doc.id !== excludeDocId) {
                    return { found: true, field: 'Unique Text ID (slug)' };
                }
            }
        }
        return { found: false, field: null };
    }

    // User Management specific helper functions
    function hideUserMessage() { userMessageArea.classList.add('hidden'); }
    function clearUserForm() {
        userDocIdInput.value = '';
        userEditNameInput.value = '';
        userEditEmailInput.value = '';
        userEditActivatedSelect.value = 'true';
        userEditExpiresAtInput.value = '';
        userEditFormSection.classList.add('hidden');
        userFormDivider.classList.add('hidden');
        hideUserMessage();
    }
    function formatTimestampForInput(timestamp) {
        if (!timestamp || typeof timestamp.toDate !== 'function') return '';
        const date = timestamp.toDate();
        const timezoneOffset = date.getTimezoneOffset() * 60000;
        const localDate = new Date(date.getTime() - timezoneOffset);
        return localDate.toISOString().slice(0, 16);
    }
    function displayUserMessage(text, type = 'success') {
        userMessageArea.textContent = text;
        userMessageArea.className = `message ${type}`;
        userMessageArea.classList.remove('hidden');
    }


    // --- Auth and Navigation ---
    auth.onAuthStateChanged(user => {
        loginScreen.style.display = user ? 'none' : 'flex';
        adminPanel.style.display = user ? 'flex' : 'none';
        
        if(user) {
            adminEmailDisplay.textContent = `Logged in as: ${user.email}`;
            // Set initial menu state based on screen size
            if (window.innerWidth >= 769) {
                mainMenu.classList.add('open'); // Open by default on desktop
                mainContentArea.style.marginLeft = '250px';
                menuToggleBtn.style.left = '265px'; // Positioned next to opened menu
            } else {
                mainMenu.classList.remove('open'); // Closed by default on mobile
                mainContentArea.style.marginLeft = '0';
                menuToggleBtn.style.left = '15px'; // Default mobile position
            }
            menuToggleBtn.style.display = 'flex'; // Ensure button is always visible when logged in
            navigateToPage('addContentPage'); // Default page after login
        } else {
            adminEmailDisplay.textContent = '';
            menuToggleBtn.style.display = 'none'; // Hide toggle button when not logged in
        }
    });

    document.getElementById('loginForm').addEventListener('submit', async e => {
        e.preventDefault();
        const btn = e.target.querySelector('button');
        setLoading(btn, true);
        try {
            await auth.signInWithEmailAndPassword(document.getElementById('loginEmail').value, document.getElementById('loginPassword').value);
            displayMessage(loginMessage, '', ''); // Clear any previous login message
        } catch (error) {
            displayMessage(loginMessage, 'Invalid credentials.', 'error');
        } finally {
            setLoading(btn, false);
        }
    });

    logoutBtn.addEventListener('click', () => auth.signOut());
    
    menuToggleBtn.addEventListener('click', () => {
        mainMenu.classList.toggle('open');
        if (mainMenu.classList.contains('open')) {
            mainContentArea.style.marginLeft = '250px';
            menuToggleBtn.style.left = '265px'; // Move button with menu
        } else {
            mainContentArea.style.marginLeft = '0';
            menuToggleBtn.style.left = '15px'; // Move button back
        }
    });

    function navigateToPage(pageId) {
        document.querySelectorAll('.page-container').forEach(p => p.classList.remove('active'));
        const page = document.getElementById(pageId);
        if (page) {
            page.classList.add('active');
            if (pageId === 'bannerPage') {
                const viewBannersTabLink = document.querySelector('.banner-tab-link[data-tab="viewBannersTab"]');
                if (viewBannersTabLink) {
                    viewBannersTabLink.click();
                }
            } else if (pageId === 'allContentPage') { 
                displayAllContent();
            }
        }
        document.querySelectorAll('.menu-link').forEach(link => {
            const isActive = link.dataset.page === pageId;
            link.classList.toggle('active', isActive);
            if (isActive) pageTitle.textContent = link.textContent.trim();
        });
        // On mobile, automatically close menu after navigating
        if (window.innerWidth < 769) { 
            mainMenu.classList.remove('open');
            mainContentArea.style.marginLeft = '0'; 
            menuToggleBtn.style.left = '15px'; 
        }
        window.scrollTo(0, 0);
    }
    document.querySelectorAll('.menu-link').forEach(link => {
        link.addEventListener('click', (e) => {
            e.preventDefault();
            navigateToPage(e.currentTarget.dataset.page);
        });
    });

    // Handle window resize for menu state
    window.addEventListener('resize', () => {
        if (auth.currentUser) { // Only adjust if logged in
            if (window.innerWidth >= 769) {
                mainMenu.classList.add('open');
                mainContentArea.style.marginLeft = '250px';
                menuToggleBtn.style.left = '265px';
            } else {
                mainMenu.classList.remove('open');
                mainContentArea.style.marginLeft = '0';
                menuToggleBtn.style.left = '15px';
            }
        }
    });


    function setupMasterContentTypeToggle(formElement) {
        const primarySelector = formElement.querySelector('.primary-content-type-selector');
        const mediaCategoriesGroup = formElement.querySelector('.media-categories-group');
        const videoUrlGroup = formElement.querySelector('.video-url-group');
        const seriesDataGroup = formElement.querySelector('.series-data-group');
        const genreSelectionGroup = formElement.querySelector('.genre-selection-group'); // Get genre group

        // Define movie and TV series categories
        const movieCategories = [
            'latest_movies', 'latest_uploads', 'Latest-Movies', 'most_liked', 'animation', 'indian', 'horror', 'comedy', 'romance', 
            'adventure', 'scifi-fantasy', 'action-thriller', 'high-school', 'nigerian'
        ];
        const tvCategories = [
            'latest_tv_shows', 'latest_uploads', 'Latest-Movies', 'most_liked',
            'upcoming_shows', 'western_series', 'Latest-TV-Series', 'k_dramas'
        ];

        function toggleFields() {
            const primaryType = primarySelector.value;
            const isTV = primaryType === 'tv';

            // Show/hide the entire categories group based on primary type
            if(mediaCategoriesGroup) mediaCategoriesGroup.style.display = 'block'; 

            // Iterate through all checkboxes within the categories group and set their display style
            const categoriesCheckboxes = mediaCategoriesGroup.querySelectorAll('input[type="checkbox"]');
            categoriesCheckboxes.forEach(checkbox => {
                const categoryValue = checkbox.value;
                const parentLabel = checkbox.parentElement; // The <label> element wrapping the checkbox

                if (isTV) {
                    // If TV series is selected, show only TV-specific categories
                    parentLabel.style.display = tvCategories.includes(categoryValue) ? 'flex' : 'none';
                } else {
                    // If Movie is selected, show only movie-specific categories
                    parentLabel.style.display = movieCategories.includes(categoryValue) ? 'flex' : 'none';
                }
            });

            // Genre selection group is always visible, as genres apply to both movies and TV.
            if (genreSelectionGroup) genreSelectionGroup.style.display = 'block'; // Ensure it's always visible

            if(videoUrlGroup) videoUrlGroup.style.display = isTV ? 'none' : 'block';
            if(seriesDataGroup) seriesDataGroup.style.display = isTV ? 'block' : 'none';
        }

        if(primarySelector) {
            primarySelector.addEventListener('change', toggleFields);
            // Call immediately to set initial state based on default selected option
            toggleFields(); 
        }
    }
    setupMasterContentTypeToggle(document.getElementById('addMovieForm'));
    setupMasterContentTypeToggle(document.getElementById('manualAddForm'));
    setupMasterContentTypeToggle(document.getElementById('editContentForm'));


    // --- TMDB Add Form Logic ---
    addMovieForm.addEventListener('submit', async e => {
        e.preventDefault();
        setLoading(addContentBtn, true);
        const primaryType = document.getElementById('primaryContentType').value;
        const isTV = primaryType === 'tv';
        const identifier = document.getElementById('contentIdentifier').value.trim();
        const vjName = document.getElementById('vjName').value.trim();
        const tmdbApiKey = document.getElementById('tmdbApiKey').value;
        const apiType = isTV ? 'tv' : 'movie';

        if (!vjName) {
            displayMessage(addMessage, 'VJ Name is required.', 'error');
            setLoading(addContentBtn, false);
            return;
        }

        const tmdbData = await (async (id, key) => {
            const isId = /^\d+$/.test(id);
            const url = isId ? `https://api.themoviedb.org/3/${apiType}/${id}?api_key=${key}` : `https://api.themoviedb.org/3/search/${apiType}?api_key=${key}&query=${encodeURIComponent(id)}`;
            try {
                const r = await fetch(url);
                if (!r.ok) {
                    console.error(`TMDB API error: ${r.status} ${r.statusText}`);
                    return null;
                }
                const d = await r.json();
                const fetchedData = isId ? d : (d.results?.[0] || null);

                if (fetchedData) {
                    const configUrl = `https://api.themoviedb.org/3/configuration?api_key=${key}`;
                    const configResponse = await fetch(configUrl);
                    const configData = await configResponse.json();
                    const baseImageUrl = configData.images.base_url + configData.images.poster_sizes[3]; // w500 for poster
                    const baseBackdropUrl = configData.images.base_url + configData.images.backdrop_sizes[2]; // w780 for backdrop

                    fetchedData.fullPosterPath = fetchedData.poster_path ? `${baseImageUrl}${fetchedData.poster_path}` : '';
                    fetchedData.fullBackdropPath = fetchedData.backdrop_path ? `${baseBackdropUrl}${fetchedData.backdrop_path}` : '';
                }
                return fetchedData;
            } catch (err) {
                console.error("Error fetching from TMDB:", err);
                return null;
            }
        })(identifier, tmdbApiKey);

        if (!tmdbData || !tmdbData.id) {
            displayMessage(addMessage, 'Could not find content on TMDB. Check name/ID or API key.', 'error');
            setLoading(addContentBtn, false);
            return;
        }

        const finalTitle = tmdbData.title || tmdbData.name;
        let payload = {
            title: finalTitle,
            tmdbId: tmdbData.id,
            slug: generateSlug(finalTitle), // Slug based on TMDB title
            posterUrl: tmdbData.fullPosterPath || '', // Use the full path
            backdropUrl: tmdbData.fullBackdropPath || '', // Add backdrop URL
            overview: tmdbData.overview || "N/A",
            vjName: vjName,
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            addedBy: auth.currentUser.email,
            // --- Collect sort_vjs and sort_genres ---
            sort_vjs: Array.from(document.querySelectorAll('#sortVjsCheckboxesTMDB input[name="sortVjsTMDB"]:checked')).map(cb => cb.value),
            sort_genres: Array.from(document.querySelectorAll('#sortGenresCheckboxesTMDB input[name="sortGenresTMDB"]:checked')).map(cb => cb.value)
        };

        // TMDB fetched genres (if available, TMDB has genres as numbers)
        // You might need a mapping here if you want string genres for TMDB items.
        // For simplicity, we'll store TMDB's genre_ids directly or leave empty if not applicable.
        payload.genres = tmdbData.genre_ids || [];

        if (isTV) {
            payload.contentType = 'tv';
            // For TV, 'type' will store the selected TV categories
            const selectedTypes = Array.from(document.querySelectorAll('#contentTypeCheckboxes input[name="contentType"]:checked')).map(cb => cb.value);
            if(selectedTypes.length === 0) {
                displayMessage(addMessage, 'Please select at least one category for TV series.', 'error');
                setLoading(addContentBtn, false);
                return;
            }
            payload.type = selectedTypes;
            try {
                const seriesDataValue = document.getElementById('seriesData').value;
                if(!seriesDataValue) {
                    displayMessage(addMessage, "Series Data (JSON) cannot be empty for TV series.", 'error');
                    setLoading(addContentBtn, false);
                    return;
                }
                const seriesInfo = JSON.parse(seriesDataValue);

                // Validate seriesInfo structure (basic validation)
                if (!Array.isArray(seriesInfo) || seriesInfo.some(s => !s.season_number || !Array.isArray(s.episodes))) {
                    throw new Error("Invalid Series Data JSON structure. Expected an array of seasons, each with an 'episodes' array.");
                }
                
                const duplicateCheck = await checkForDuplicates(payload);
                if (duplicateCheck.found) {
                    displayMessage(addMessage, `Duplicate found by ${duplicateCheck.field}. Addition denied.`, 'error');
                    setLoading(addContentBtn, false);
                    return;
                }

                // Save the main series document
                const docRef = await db.collection('movies').add(payload); 
                const seriesDocId = docRef.id;

                // Save episodes to a subcollection
                for (const season of seriesInfo) {
                    for (const episode of season.episodes) {
                        await db.collection('movies').doc(seriesDocId).collection('episodes').add({
                            season_number: season.season_number,
                            episode_number: episode.episode_number,
                            title: episode.title || `Episode ${episode.episode_number}`,
                            videoUrl: episode.videoUrl,
                            // Add any other episode specific data like overview, air_date, etc.
                            overview: episode.overview || '',
                            air_date: episode.air_date ? firebase.firestore.Timestamp.fromDate(new Date(episode.air_date)) : null,
                            addedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                }

                displayMessage(addMessage, 'TV series and episodes added successfully!', 'success');
                addMovieForm.reset();
                // Reset new sort checkboxes after successful add
                document.querySelectorAll('#sortVjsCheckboxesTMDB input').forEach(cb => cb.checked = false);
                document.querySelectorAll('#sortGenresCheckboxesTMDB input').forEach(cb => cb.checked = false);

            } catch (err) {
                console.error("Error adding TV series or parsing JSON:", err);
                displayMessage(addMessage, `Error processing TV Series: ${err.message}`, 'error');
            } finally {
                setLoading(addContentBtn, false);
            }

        } else {    
            payload.contentType = 'movie';
            // For movies, 'type' will store the selected movie categories
            const selectedTypes = Array.from(document.querySelectorAll('#contentTypeCheckboxes input[name="contentType"]:checked')).map(cb => cb.value);
            if(selectedTypes.length === 0) {
                displayMessage(addMessage, 'Please select at least one category for movies.', 'error');
                setLoading(addContentBtn, false);
                return;
            }
            payload.type = selectedTypes;
            payload.videoUrl = document.getElementById('videoSourceUrl').value;

            try {
                const duplicateCheck = await checkForDuplicates(payload);
                if (duplicateCheck.found) {
                    displayMessage(addMessage, `Duplicate found by ${duplicateCheck.field}. Addition denied.`, 'error');
                } else {
                    await db.collection('movies').add(payload);
                    displayMessage(addMessage, 'Content added successfully!', 'success');
                    addMovieForm.reset();
                    // Reset new sort checkboxes after successful add
                    document.querySelectorAll('#sortVjsCheckboxesTMDB input').forEach(cb => cb.checked = false);
                    document.querySelectorAll('#sortGenresCheckboxesTMDB input').forEach(cb => cb.checked = false);
                }
            } catch (error) {
                console.error("Error adding document:", error);
                displayMessage(addMessage, `Error: ${error.message}`, 'error');
            } finally {
                setLoading(addContentBtn, false);
            }
        }
    });
    
    // --- Manual Add Form Logic ---
    manualAddForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        setLoading(manualAddBtn, true);
        
        const manualTitle = document.getElementById('manualTitle').value.trim();
        const manualVjName = document.getElementById('manualVjName').value.trim();
        const referenceIdInput = document.getElementById('manualReferenceId').value.trim(); 
        const manualPosterUrl = document.getElementById('manualPosterUrl').value.trim();
        const manualBackdropUrl = document.getElementById('manualBackdropUrl').value.trim();

        if (!manualTitle || !manualVjName || !manualPosterUrl) {
            displayMessage(manualAddMessage, 'Title, VJ Name, and Poster Image URL are required.', 'error');
            setLoading(manualAddBtn, false);
            return;
        }

        let tmdbId = null;
        let slug = generateSlug(manualTitle);

        if (referenceIdInput) {
            if (/^\d+$/.test(referenceIdInput)) {
                tmdbId = Number(referenceIdInput);
                displayMessage(manualAddMessage, `Warning: You entered a numeric ID. This will be saved as a TMDB ID, not a custom slug. Slug will be '${slug}'.`, 'warn');
            } else {
                tmdbId = null;
                slug = generateSlug(referenceIdInput);
            }
        }
        
        // Get selected genres for manual add
        const selectedGenres = Array.from(document.querySelectorAll('#manualGenreCheckboxes input[name="manualGenre"]:checked')).map(cb => cb.value);
        if(selectedGenres.length === 0) { 
            displayMessage(manualAddMessage, 'Please select at least one genre.', 'error');
            setLoading(manualAddBtn, false);
            return;
        }

        let payload = {
            title: manualTitle,
            slug: slug, // This will be the custom slug if referenceIdInput was text
            overview: document.getElementById('manualOverview').value,
            posterUrl: manualPosterUrl,
            backdropUrl: manualBackdropUrl,
            vjName: manualVjName,
            tmdbId: tmdbId, // This will be the numeric TMDB ID or null
            genres: selectedGenres, // Add selected genres to payload
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            addedBy: auth.currentUser.email,
            // --- Collect sort_vjs and sort_genres ---
            sort_vjs: Array.from(document.querySelectorAll('#sortVjsCheckboxesManual input[name="sortVjsManual"]:checked')).map(cb => cb.value),
            sort_genres: Array.from(document.querySelectorAll('#sortGenresCheckboxesManual input[name="sortGenresManual"]:checked')).map(cb => cb.value)
        };

        const primaryType = document.getElementById('manualPrimaryContentType').value;
        if (primaryType === 'tv') {
            payload.contentType = 'tv';
            // For TV, 'type' will store the selected TV categories
            const selectedTypes = Array.from(document.querySelectorAll('#manualContentTypeCheckboxes input[name="manualContentType"]:checked')).map(cb => cb.value);
            if(selectedTypes.length === 0) {
                displayMessage(manualAddMessage, 'Please select at least one category for TV series.', 'error');
                setLoading(manualAddBtn, false);
                return;
            }
            payload.type = selectedTypes;
            try {
                const seriesDataValue = document.getElementById('manualSeriesData').value;
                if(!seriesDataValue) throw new Error("Series Data (JSON) cannot be empty for TV series.");
                const seriesInfo = JSON.parse(seriesDataValue);

                   // Validate seriesInfo structure (basic validation)
                if (!Array.isArray(seriesInfo) || seriesInfo.some(s => !s.season_number || !Array.isArray(s.episodes))) {
                    throw new Error("Invalid Series Data JSON structure. Expected an array of seasons, each with an 'episodes' array.");
                }

                // Check for duplicates before saving anything
                const duplicateCheck = await checkForDuplicates(payload);
                if (duplicateCheck.found) {
                    displayMessage(manualAddMessage, `Duplicate found by ${duplicateCheck.field}. Addition denied.`, 'error');
                    setLoading(manualAddBtn, false);
                    return;
                }

                // Save the main series document
                let seriesDocRef;
                if (payload.slug) {
                    // Use slug as document ID if available
                    seriesDocRef = db.collection('movies').doc(payload.slug);
                    await seriesDocRef.set(payload);
                } else {
                    // Let Firestore generate an ID
                    seriesDocRef = await db.collection('movies').add(payload);
                }
                const seriesDocId = seriesDocRef.id;

                // Save episodes to a subcollection
                for (const season of seriesInfo) {
                    for (const episode of season.episodes) {
                        await db.collection('movies').doc(seriesDocId).collection('episodes').add({
                            season_number: season.season_number,
                            episode_number: episode.episode_number,
                            title: episode.title || `Episode ${episode.episode_number}`,
                            videoUrl: episode.videoUrl,
                            overview: episode.overview || '',
                            air_date: episode.air_date ? firebase.firestore.Timestamp.fromDate(new Date(episode.air_date)) : null,
                            addedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                }

                displayMessage(manualAddMessage, 'TV series and episodes added successfully!', 'success');
                manualAddForm.reset();
                document.querySelectorAll('#manualGenreCheckboxes input[name="manualGenre"]').forEach(cb => cb.checked = false);
                // Reset new sort checkboxes after successful add
                document.querySelectorAll('#sortVjsCheckboxesManual input').forEach(cb => cb.checked = false);
                document.querySelectorAll('#sortGenresCheckboxesManual input').forEach(cb => cb.checked = false);

            } catch (err) {
                console.error("Error adding TV series manually or parsing JSON:", err);
                displayMessage(manualAddMessage, `Error processing TV Series: ${err.message}`, 'error');
            } finally {
                setLoading(manualAddBtn, false);
            }

        } else {
            payload.contentType = 'movie';
            // For movies, 'type' will store the selected movie categories
            const selectedTypes = Array.from(document.querySelectorAll('#manualContentTypeCheckboxes input[name="manualContentType"]:checked')).map(cb => cb.value);
            if (selectedTypes.length === 0) {
                displayMessage(manualAddMessage, 'Please select at least one category for movies.', 'error');
                setLoading(manualAddBtn, false);
                return;
            }
            payload.type = selectedTypes;
            payload.videoUrl = document.getElementById('manualVideoSourceUrl').value;

            try {
                const duplicateCheck = await checkForDuplicates(payload);
                if (duplicateCheck.found) {
                    displayMessage(manualAddMessage, `Duplicate found by ${duplicateCheck.field}. Addition denied.`, 'error');
                } else {
                    await db.collection('movies').add(payload);
                    displayMessage(manualAddMessage, 'Content added successfully!', 'success');
                    manualAddForm.reset();
                    // After successful add, reset genre and new sort checkboxes
                    document.querySelectorAll('#manualGenreCheckboxes input[name="manualGenre"]').forEach(cb => cb.checked = false);
                    document.querySelectorAll('#sortVjsCheckboxesManual input').forEach(cb => cb.checked = false);
                    document.querySelectorAll('#sortGenresCheckboxesManual input').forEach(cb => cb.checked = false);
                }
            } catch (error) {
                console.error("Error adding document manually:", error);
                displayMessage(manualAddMessage, `Error: ${error.message}`, 'error');
            } finally {
                setLoading(manualAddBtn, false);
            }
        }
    });

    // --- Manage & Edit Content Logic ---
    searchManageBtn.addEventListener('click', async () => {
        setLoading(searchManageBtn, true);
        manageSearchResults.innerHTML = '';
        selectedMoviesForDeletion.clear();
        confirmDeleteBtn.style.display = 'none';
        const term = document.getElementById('manageContentIdentifier').value.trim();
        if (!term) {
            displayMessage(manageMessage, 'Enter a name or ID to search.', 'error');
            setLoading(searchManageBtn, false);
            return;
        }
        
        try {
            let docs = [];
            const lowerCaseTerm = term.toLowerCase();
            
            // Search only in the primary db
            const snapshot = await db.collection('movies').get(); 
            snapshot.forEach(doc => {
                const data = doc.data();
                // Check if TMDB ID matches (numeric search)
                if (data.tmdbId && /^\d+$/.test(term) && data.tmdbId === Number(term)) {
                    docs.push({ id: doc.id, ...data });
                } 
                // Check if title or slug includes the term (case-insensitive)
                else if (
                    (data.title && data.title.toLowerCase().includes(lowerCaseTerm)) || 
                    (data.slug && data.slug.toLowerCase().includes(lowerCaseTerm))
                ) {
                    docs.push({ id: doc.id, ...data });
                }
            });

            if(docs.length === 0) {
                displayMessage(manageMessage, 'No content found matching your search.', 'info');
            } else {
                docs.forEach(item => {
                    manageSearchResults.innerHTML += `
                        <div class="result-item">
                            <span><strong>${item.title}</strong> (ID: ${item.tmdbId || item.slug || 'N/A'}) - Type: ${item.contentType || 'N/A'}</span>
                            <div class="result-item-actions">
                                <button class="action-btn edit" data-id="${item.id}">Edit</button>
                                <button class="action-btn select-delete" data-id="${item.id}">Select</button>
                            </div>
                        </div>
                    `;
                });
                displayMessage(manageMessage, `Found ${docs.length} item(s).`, 'success');
            }
        } catch (err) {
            console.error("Error searching content:", err);
            displayMessage(manageMessage, `Error searching content: ${err.message}`, 'error');
        } finally {
            setLoading(searchManageBtn, false);
        }
    });
    
    manageSearchResults.addEventListener('click', e => {
        if(e.target.matches('.select-delete')){
            const btn = e.target;
            const id = btn.dataset.id;
            if(selectedMoviesForDeletion.has(id)){
                selectedMoviesForDeletion.delete(id);
                btn.classList.remove('selected');
                btn.textContent = 'Select';
            } else {
                selectedMoviesForDeletion.add(id);
                btn.classList.add('selected');
                btn.textContent = 'Selected';
            }
            confirmDeleteBtn.style.display = selectedMoviesForDeletion.size > 0 ? 'block' : 'none';
            confirmDeleteBtn.textContent = `Delete Selected (${selectedMoviesForDeletion.size})`;
        }
        if (e.target.matches('.action-btn.edit')) {
            const docId = e.target.dataset.id;
            loadContentForEditing(docId);
        }
    });
    
    confirmDeleteBtn.addEventListener('click', async () => {
        if(confirm(`Are you sure you want to delete ${selectedMoviesForDeletion.size} item(s)? This action cannot be undone.`)){
            setLoading(confirmDeleteBtn, true);
            const deletePromises = [];
            selectedMoviesForDeletion.forEach(id => {
                deletePromises.push(db.collection('movies').doc(id).delete());
            });

            try {
                await Promise.all(deletePromises);
                displayMessage(manageMessage, `Deleted ${selectedMoviesForDeletion.size} items successfully.`, 'success');
                manageSearchResults.innerHTML = ''; // Clear results after deletion
                confirmDeleteBtn.style.display = 'none';
                selectedMoviesForDeletion.clear();
            } catch(err){
                console.error("Error deleting content:", err);
                displayMessage(manageMessage, `Error deleting content: ${err.message}`, 'error');
            } finally {
                setLoading(confirmDeleteBtn, false);
            }
        }
    });

    // --- Edit Content Logic ---
    async function loadContentForEditing(id) {
        try {
            const docRef = db.collection('movies').doc(id);
            const docSnap = await docRef.get();
            
            if (!docSnap.exists) {
                displayMessage(manageMessage, 'Content not found or already deleted.', 'error');
                return;
            }
            const data = docSnap.data();
            
            editContentForm.reset();
            document.getElementById('editDocId').value = docSnap.id;
            // No need for projectId dataset as we are only using one project

            document.getElementById('editTitle').value = data.title || '';
            document.getElementById('editOverview').value = data.overview || '';
            document.getElementById('editPosterUrl').value = data.posterUrl || '';
            document.getElementById('editBackdropUrl').value = data.backdropUrl || ''; // Populate backdrop URL
            document.getElementById('editVjName').value = data.vjName || '';
            
            // Map the `movie` and `tv` values back to `latest_movies` and `latest_tv_shows` for display if needed
            const primaryTypeSelector = document.getElementById('editPrimaryContentType');
            primaryTypeSelector.value = data.contentType === 'tv' ? 'tv' : 'movie';
            primaryTypeSelector.dispatchEvent(new Event('change')); // Trigger visibility logic

            // Populate "Reference ID" with tmdbId if present, otherwise with slug if it's not generated from title
            const isSlugFromTitle = generateSlug(data.title || '') === data.slug;
            document.getElementById('editReferenceId').value = data.tmdbId || (!isSlugFromTitle && data.slug ? data.slug : '');


            // Uncheck all category checkboxes first
            document.querySelectorAll('#editContentTypeCheckboxes input').forEach(cb => {
                cb.checked = false; 
            });

            // Set checked status based on `data.type`
            if (Array.isArray(data.type)) {
                data.type.forEach(typeValue => {
                    // Adjust typeValue for the admin panel's specific display values
                    let displayValue = typeValue;
                    if (typeValue === 'movie') displayValue = 'latest_movies';
                    if (typeValue === 'tv') displayValue = 'latest_tv_shows';
                    if (typeValue === 'popular') displayValue = 'latest_uploads'; // Map 'popular' back to 'latest_uploads'

                    const checkbox = document.querySelector(`#editContentTypeCheckboxes input[value="${displayValue}"]`);
                    if (checkbox) checkbox.checked = true;
                });
            }

            // Uncheck all genre checkboxes first
            document.querySelectorAll('#editGenreCheckboxes input[name="editGenre"]').forEach(cb => {
                cb.checked = false;
            });
            // Set checked status for genres based on `data.genres`
            if (Array.isArray(data.genres)) {
                data.genres.forEach(genreValue => {
                    const checkbox = document.querySelector(`#editGenreCheckboxes input[value="${genreValue}"]`);
                    if (checkbox) checkbox.checked = true;
                });
            }
            
            // NEW: Populate sort_vjs and sort_genres checkboxes from fetched data
            populateCheckboxes('sortVjsCheckboxesEdit', 'sortVjsEdit', VJ_LIST, data.sort_vjs);
            populateCheckboxes('sortGenresCheckboxesEdit', 'sortGenresEdit', GENRE_LIST, data.sort_genres);
            
            if (data.contentType === 'movie') {
                document.getElementById('editVideoSourceUrl').value = data.videoUrl || '';
                // Clear series data if it was previously a TV series
                document.getElementById('editSeriesData').value = ''; 
            } else if (data.contentType === 'tv') {
                // Fetch episodes for TV series
                const episodesSnapshot = await db.collection('movies').doc(id).collection('episodes').get();
                const seasonsData = {};

                episodesSnapshot.forEach(episodeDoc => {
                    const episodeData = episodeDoc.data();
                    const seasonNum = episodeData.season_number;
                    if (!seasonsData[seasonNum]) {
                        seasonsData[seasonNum] = { season_number: seasonNum, episodes: [] };
                    }
                    seasonsData[seasonNum].episodes.push({
                        episode_number: episodeData.episode_number,
                        title: episodeData.title || `Episode ${episodeData.episode_number}`,
                        videoUrl: episodeData.videoUrl,
                        overview: episodeData.overview || '',
                        air_date: episodeData.air_date ? episodeData.air_date.toDate().toISOString().slice(0, 10) : ''
                    });
                });

                // Convert to array and sort by season and then episode number
                const formattedSeriesInfo = Object.values(seasonsData).sort((a, b) => a.season_number - b.season_number);
                formattedSeriesInfo.forEach(season => {
                    season.episodes.sort((a, b) => a.episode_number - b.episode_number);
                });

                document.getElementById('editSeriesData').value = JSON.stringify(formattedSeriesInfo, null, 2);
                // Clear video URL if it was previously a movie
                document.getElementById('editVideoSourceUrl').value = ''; 
            }

            navigateToPage('editContentPage');
        } catch (err) {
            console.error("Error loading content for editing:", err);
            displayMessage(manageMessage, `Error loading content: ${err.message}`, 'error');
        }
    }

    editContentForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        setLoading(updateContentBtn, true);
        const docId = document.getElementById('editDocId').value;

        if (!docId) {
            displayMessage(editMessage, 'No document ID found. Cannot update.', 'error');
            setLoading(updateContentBtn, false);
            return;
        }
        const editTitle = document.getElementById('editTitle').value.trim();
        const editVjName = document.getElementById('editVjName').value.trim();
        const referenceIdInput = document.getElementById('editReferenceId').value.trim();  
        const editPosterUrl = document.getElementById('editPosterUrl').value.trim();
        const editBackdropUrl = document.getElementById('editBackdropUrl').value.trim(); // Get backdrop URL

        if (!editTitle || !editVjName || !editPosterUrl) { // Poster URL is now required
            displayMessage(editMessage, 'Title, VJ Name, and Poster Image URL are required.', 'error');
            setLoading(updateContentBtn, false);
            return;
        }

        let tmdbId = null;
        let slug = generateSlug(editTitle);

        if(referenceIdInput) {
            if(/^\d+$/.test(referenceIdInput)) {
                tmdbId = Number(referenceIdInput);
            } else {
                tmdbId = null;
                slug = generateSlug(referenceIdInput);
            }
        }
            
        // Get selected genres from the edit form
        const selectedGenres = Array.from(document.querySelectorAll('#editGenreCheckboxes input[name="editGenre"]:checked')).map(cb => cb.value);
        if(selectedGenres.length === 0) { 
            displayMessage(editMessage, 'Please select at least one genre.', 'error');
            setLoading(updateContentBtn, false);
            return;
        }

        let payload = {
            title: editTitle,
            slug: slug,
            overview: document.getElementById('editOverview').value,
            posterUrl: editPosterUrl,
            backdropUrl: editBackdropUrl,
            vjName: editVjName,
            tmdbId: tmdbId,
            genres: selectedGenres, // Add selected genres to payload
            updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
            // --- Collect updated sort_vjs and sort_genres ---
            sort_vjs: Array.from(document.querySelectorAll('#sortVjsCheckboxesEdit input[name="sortVjsEdit"]:checked')).map(cb => cb.value),
            sort_genres: Array.from(document.querySelectorAll('#sortGenresCheckboxesEdit input[name="sortGenresEdit"]:checked')).map(cb => cb.value)
        };

        const primaryType = document.getElementById('editPrimaryContentType').value;
        if (primaryType === 'tv') {
            payload.contentType = 'tv';
            // For TV, 'type' will store the selected TV categories
            const selectedTypes = Array.from(document.querySelectorAll('#editContentTypeCheckboxes input[name="editContentType"]:checked')).map(cb => {
                // Map the displayed values back to original stored values
                if (cb.value === 'latest_movies') return 'movie';
                if (cb.value === 'latest_tv_shows') return 'tv';
                if (cb.value === 'latest_uploads') return 'popular';
                return cb.value; // Return as is for other values
            });
            if (selectedTypes.length === 0) {
                    displayMessage(editMessage, 'Please select at least one category for TV series.', 'error');
                    setLoading(updateContentBtn, false);
                    return;
            }
            payload.type = selectedTypes;
            
            try {
                const seriesDataValue = document.getElementById('editSeriesData').value;
                if(!seriesDataValue) throw new Error("Series Data (JSON) cannot be empty for TV series.");
                const seriesInfo = JSON.parse(seriesDataValue);

                // Validate seriesInfo structure (basic validation)
                if (!Array.isArray(seriesInfo) || seriesInfo.some(s => !s.season_number || !Array.isArray(s.episodes))) {
                    throw new Error("Invalid Series Data JSON structure. Expected an array of seasons, each with an 'episodes' array.");
                }
                
                // Remove videoUrl and seriesInfo field (if it exists) from main document
                payload.videoUrl = firebase.firestore.FieldValue.delete(); 
                if (payload.seriesInfo) { // Check if seriesInfo exists before trying to delete it
                    payload.seriesInfo = firebase.firestore.FieldValue.delete();
                }

                const duplicateCheck = await checkForDuplicates(payload, docId);  
                if (duplicateCheck.found) {
                    displayMessage(editMessage, `Update failed. Another entry exists with this ${duplicateCheck.field}.`, 'error');
                    setLoading(updateContentBtn, false);
                    return;
                }

                // Update main series document
                await db.collection('movies').doc(docId).update(payload);

                // Delete existing episodes subcollection and re-add them
                const episodesCollectionRef = db.collection('movies').doc(docId).collection('episodes');
                const existingEpisodesSnapshot = await episodesCollectionRef.get();
                const deleteEpisodePromises = [];
                existingEpisodesSnapshot.forEach(episodeDoc => {
                    deleteEpisodePromises.push(episodesCollectionRef.doc(episodeDoc.id).delete());
                });
                await Promise.all(deleteEpisodePromises);

                // Add new episodes
                for (const season of seriesInfo) {
                    for (const episode of season.episodes) {
                        await episodesCollectionRef.add({
                            season_number: episode.season_number || season.season_number, // Prefer episode's own season_number if present
                            episode_number: episode.episode_number,
                            title: episode.title || `Episode ${episode.episode_number}`,
                            videoUrl: episode.videoUrl,
                            overview: episode.overview || '',
                            air_date: episode.air_date ? firebase.firestore.Timestamp.fromDate(new Date(episode.air_date)) : null,
                            addedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                }

                displayMessage(editMessage, 'TV series and episodes updated successfully!', 'success');
                setTimeout(() => navigateToPage('allContentPage'), 2000);

            } catch (err) {
                    displayMessage(editMessage, `Error updating TV Series: ${err.message}`, 'error');
                    setLoading(updateContentBtn, false);
                    return;
            }
        } else {    
            payload.contentType = 'movie';
            // For movies, 'type' will store the selected movie categories
            const selectedTypes = Array.from(document.querySelectorAll('#editContentTypeCheckboxes input[name="editContentType"]:checked')).map(cb => {
                // Map the displayed values back to original stored values
                if (cb.value === 'latest_movies') return 'movie';
                if (cb.value === 'latest_tv_shows') return 'tv';
                if (cb.value === 'latest_uploads') return 'popular';
                return cb.value; // Return as is for other values
            });
            if (selectedTypes.length === 0) {
                    displayMessage(editMessage, 'Please select at least one category for movies.', 'error');
                    setLoading(updateContentBtn, false);
                    return;
            }
            payload.type = selectedTypes;
            payload.videoUrl = document.getElementById('editVideoSourceUrl').value;
            payload.seriesInfo = firebase.firestore.FieldValue.delete(); // Ensure seriesInfo is removed for movies

            const duplicateCheck = await checkForDuplicates(payload, docId);  
            if (duplicateCheck.found) {
                displayMessage(editMessage, `Update failed. Another entry exists with this ${duplicateCheck.field}.`, 'error');
                setLoading(updateContentBtn, false);
                return;
            }

            await db.collection('movies').doc(docId).update(payload);
            displayMessage(editMessage, 'Content updated successfully!', 'success');
            setTimeout(() => navigateToPage('allContentPage'), 2000);
        }
        
        try {
            // All updates happen within the if/else blocks now.
        } catch (error) {
            console.error("Update Error:", error);
            displayMessage(editMessage, `Update Error: ${error.message}`, 'error');
        } finally {
            setLoading(updateContentBtn, false);
        }
    });

    cancelEditBtn.addEventListener('click', () => { navigateToPage('allContentPage'); }); 

    // --- All Content Page Logic ---
    async function displayAllContent() {
        allContentContainer.innerHTML = '<div class="message info" style="display:block;">Loading all content...</div>';
        selectedAllContentForDeletion.clear();
        updateDeleteSelectedButton(); 
        
        const filterValue = allContentFilter.value;
        const filterText = allContentFilter.options[allContentFilter.selectedIndex].text;
        
        // Adjust button text and behavior based on filter
        if (filterValue === 'all' || filterValue === 'latest_movies' || filterValue === 'latest_tv_shows') {
            deleteSelectedAllContentBtn.textContent = `Delete Selected Content (${selectedAllContentForDeletion.size})`;
            deleteSelectedAllContentBtn.classList.remove('remove-from-category-mode'); // Optional: add a class for styling
            deleteSelectedAllContentBtn.dataset.deleteMode = 'permanent';
        } else {
            deleteSelectedAllContentBtn.textContent = `Remove Selected from ${filterText} (${selectedAllContentForDeletion.size})`;
            deleteSelectedAllContentBtn.classList.add('remove-from-category-mode'); // Optional: add a class for styling
            deleteSelectedAllContentBtn.dataset.deleteMode = 'category-removal';
        }

        try {
            let docsToDisplay = [];

            let query = db.collection('movies').orderBy('createdAt', 'desc');
            
            if (filterValue !== 'all') {
                // For 'latest_movies' or 'latest_tv_shows' primary content type filters
                if (filterValue === 'latest_movies') {
                    query = query.where('contentType', '==', 'movie');
                } else if (filterValue === 'latest_tv_shows') {
                    query = query.where('contentType', '==', 'tv');
                }
                // For specific categories (e.g., 'animation', 'horror'), query the 'type' array
                else {
                    // Map filterValue back to the actual stored type value if it's a renamed one
                    let actualFilterValue = filterValue;
                    if (filterValue === 'latest_movies') actualFilterValue = 'movie';
                    if (filterValue === 'latest_tv_shows') actualFilterValue = 'tv';
                    if (filterValue === 'latest_uploads') actualFilterValue = 'popular';

                    query = query.where('type', 'array-contains', actualFilterValue);
                }
            }
            const snapshot = await query.get();
            snapshot.forEach(doc => {
                docsToDisplay.push({ id: doc.id, ...doc.data() });
            });
            
            if (docsToDisplay.length === 0) {
                allContentContainer.innerHTML = '';
                displayMessage(allContentMessage, 'No content found.', 'info');
                return;
            }
            
            allContentContainer.innerHTML = '';
            docsToDisplay.forEach(item => {
                const imageUrl = item.posterUrl || 'https://placehold.co/500x750/333/eee?text=No+Poster'; 
                const title = item.title || 'Untitled';
                const vjName = item.vjName || 'Unknown VJ';
                // Display TMDB ID or custom slug
                const contentId = item.tmdbId || item.slug || 'N/A'; 

                // Determine button text based on filterType
                const individualButtonText = (filterValue === 'all' || filterValue === 'latest_movies' || filterValue === 'latest_tv_shows') ? 'Delete' : 'Remove from Category';
                const individualButtonClass = (filterValue === 'all' || filterValue === 'latest_movies' || filterValue === 'latest_tv_shows') ? 'delete' : 'remove-from-category';

                const cardHtml = `
                    <div class="content-card">
                        <input type="checkbox" class="select-card-checkbox" data-id="${item.id}">
                        <img src="${imageUrl}" alt="${title}" onerror="this.onerror=null; this.src='/Upload/Logo.png';">
                        <div class="content-card-content">
                            <h3>${title}</h3>
                            <p class="vj-name">VJ: ${vjName}</p>
                            <p class="content-id-display">ID: ${contentId}</p>
                            <div class="content-card-actions">
                                <button class="action-btn edit" data-id="${item.id}">Edit</button>
                                <button class="action-btn ${individualButtonClass}" data-id="${item.id}">${individualButtonText}</button>
                            </div>
                        </div>
                    </div>
                `;
                allContentContainer.insertAdjacentHTML('beforeend', cardHtml);
            });
            displayMessage(allContentMessage, `Found ${docsToDisplay.length} item(s).`, 'success');

        } catch (err) {
            console.error("Error displaying all content:", err);
            allContentContainer.innerHTML = '';
            displayMessage(allContentMessage, `Error: ${err.message}`, 'error');
        }
    }

    function updateDeleteSelectedButton() {
        selectedAllContentCount.textContent = selectedAllContentForDeletion.size;
        deleteSelectedAllContentBtn.style.display = selectedAllContentForDeletion.size > 0 ? 'block' : 'none';
        
        // Update the text on the main button as well
        const filterValue = allContentFilter.value;
        const filterText = allContentFilter.options[allContentFilter.selectedIndex].text;
        if (filterValue === 'all' || filterValue === 'latest_movies' || filterValue === 'latest_tv_shows') {
            deleteSelectedAllContentBtn.textContent = `Delete Selected Content (${selectedAllContentForDeletion.size})`;
        } else {
            deleteSelectedAllContentBtn.textContent = `Remove Selected from ${filterText} (${selectedAllContentForDeletion.size})`;
        }
    }

    allContentFilter.addEventListener('change', displayAllContent);

    // Function to remove a specific category from a content item
    async function removeContentFromCategory(docId, categoryToRemove) {
        const docRef = db.collection('movies').doc(docId);
        const docSnap = await docRef.get();

        if (docSnap.exists) {
            const currentTypes = docSnap.data().type || [];
            // Map the categoryToRemove back to its original stored value if it was a renamed display value
            let actualCategoryToRemove = categoryToRemove;
            if (categoryToRemove === 'latest_movies') actualCategoryToRemove = 'movie';
            if (categoryToRemove === 'latest_tv_shows') actualCategoryToRemove = 'tv';
            if (categoryToRemove === 'latest_uploads') actualCategoryToRemove = 'popular';

            const updatedTypes = currentTypes.filter(type => type !== actualCategoryToRemove);
            
            await docRef.update({
                type: updatedTypes,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            return true;
        }
        return false;
    }

    allContentContainer.addEventListener('click', async e => {
        const target = e.target;
        // For checkbox or buttons, get the docId from dataset
        const cardElement = target.closest('.content-card');
        const docId = cardElement?.querySelector('.select-card-checkbox')?.dataset.id || target.dataset.id;
        
        if (!docId) return; // Exit if no id found

        const filterValue = allContentFilter.value;
        const filterText = allContentFilter.options[allContentFilter.selectedIndex].text;

        if (target.matches('.select-card-checkbox')) {
            if (target.checked) {
                selectedAllContentForDeletion.add(docId);
            } else {
                selectedAllContentForDeletion.delete(docId);
            }
            updateDeleteSelectedButton();
        } else if (target.matches('.action-btn.edit')) {
            loadContentForEditing(docId);
        } else if (target.matches('.action-btn.delete')) { // This is for permanent delete
            if (confirm(`Are you sure you want to delete this content permanently? This cannot be undone.`)) {
                setLoading(target, true);
                try {
                    await db.collection('movies').doc(docId).delete();
                    displayMessage(allContentMessage, 'Content deleted successfully!', 'success');
                    selectedAllContentForDeletion.delete(docId); 
                    updateDeleteSelectedButton();
                    displayAllContent(); 
                } catch (err) {
                    console.error("Error deleting content:", err);
                    displayMessage(allContentMessage, `Error deleting content: ${err.message}`, 'error');
                } finally {
                    setLoading(target, false);
                }
            }
        } else if (target.matches('.action-btn.remove-from-category')) { // This is for category removal
            if (confirm(`Are you sure you want to remove this content from the "${filterText}" category? It will not be permanently deleted.`)) {
                setLoading(target, true);
                try {
                    const success = await removeContentFromCategory(docId, filterValue);
                    if (success) {
                        displayMessage(allContentMessage, `Content removed from "${filterText}" category successfully!`, 'success');
                        selectedAllContentForDeletion.delete(docId); 
                        updateDeleteSelectedButton();
                        displayAllContent(); // Re-display to update list
                    } else {
                        displayMessage(allContentMessage, 'Failed to remove content from category: Document not found.', 'error');
                    }
                } catch (err) {
                    console.error("Error removing from category:", err);
                    displayMessage(allContentMessage, `Error removing from category: ${err.message}`, 'error');
                } finally {
                    setLoading(target, false);
                }
            }
        }
    });

    deleteSelectedAllContentBtn.addEventListener('click', async () => {
        if (selectedAllContentForDeletion.size === 0) {
            displayMessage(allContentMessage, 'No content selected for action.', 'info');
            return;
        }
        
        const filterValue = allContentFilter.value;
        const filterText = allContentFilter.options[allContentFilter.selectedIndex].text;
        const isPermanentDelete = (filterValue === 'all' || filterValue === 'latest_movies' || filterValue === 'latest_tv_shows');

        let confirmationMessage;
        let successMessage;
        let errorMessage;
        let actionPromises = [];

        if (isPermanentDelete) {
            confirmationMessage = `Are you sure you want to delete ${selectedAllContentForDeletion.size} item(s) permanently? This action cannot be undone.`;
            successMessage = `Deleted ${selectedAllContentForDeletion.size} items successfully.`;
            errorMessage = `Error deleting selected content: `;
        } else {
            confirmationMessage = `Are you sure you want to remove ${selectedAllContentForDeletion.size} item(s) from the "${filterText}" category? They will not be permanently deleted.`;
            successMessage = `Removed ${selectedAllContentForDeletion.size} items from "${filterText}" category successfully.`;
            errorMessage = `Error removing selected content from category: `;
        }

        if (confirm(confirmationMessage)) {
            setLoading(deleteSelectedAllContentBtn, true);
            
            selectedAllContentForDeletion.forEach(id => {
                if (isPermanentDelete) {
                    actionPromises.push(db.collection('movies').doc(id).delete());
                } else {
                    actionPromises.push(removeContentFromCategory(id, filterValue));
                }
            });

            try {
                await Promise.all(actionPromises);
                displayMessage(allContentMessage, successMessage, 'success');
                selectedAllContentForDeletion.clear(); 
                updateDeleteSelectedButton();
                displayAllContent(); 
            } catch (err) {
                console.error(errorMessage, err);
                displayMessage(allContentMessage, `${errorMessage}${err.message}`, 'error');
            } finally {
                setLoading(deleteSelectedAllContentBtn, false);
            }
        }
    });


    // --- Banner logic ---
    async function displayAllBanners() {
        allBannersContainer.innerHTML = '<div class="message info" style="display:block;">Loading banners...</div>';
        try {
            const snapshot = await db.collection('banners').orderBy('updatedAt', 'desc').limit(10).get();
            if (snapshot.empty) {
                allBannersContainer.innerHTML = '';
                displayMessage(viewBannersMessage, 'No banners found. Add one from the "Add/Edit Banner" tab.', 'info');
                return;
            }
            allBannersContainer.innerHTML = '';
            snapshot.forEach(doc => {
                const banner = doc.data();
                const card = `
                    <div class="banner-card">
                        <img src="${banner.imageUrl}" alt="${banner.title}" onerror="this.src='https://placehold.co/500x300/333/eee?text=No+Image';">
                        <div class="banner-card-content">
                            <h3>${banner.title}</h3>
                            <p>${(banner.description || 'No description available.').substring(0, 100)}...</p>
                            <div class="banner-card-actions">
                                <button class="action-btn edit" data-id="${doc.id}">Edit</button>
                                <button class="action-btn delete" data-id="${doc.id}">Delete</button>
                            </div>
                        </div>
                    </div>
                `;
                allBannersContainer.insertAdjacentHTML('beforeend', card);
            });
            displayMessage(viewBannersMessage, `Found ${snapshot.size} banner(s).`, 'success');
        } catch (err) {
            console.error("Error displaying banners:", err);
            allBannersContainer.innerHTML = '';
            displayMessage(viewBannersMessage, `Error: ${err.message}`, 'error');
        }
    }

    bannerNavTabs.addEventListener('click', e => {
        if (e.target.matches('.banner-tab-link')) {
            const tabId = e.target.dataset.tab;
            document.querySelectorAll('.banner-tab-link').forEach(t => t.classList.remove('active'));
            e.target.classList.add('active');
            document.querySelectorAll('.banner-tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
            if (tabId === 'viewBannersTab') {
                displayAllBanners();
            }
        }
    });

    allBannersContainer.addEventListener('click', async e => {
        const target = e.target;
        if (target.matches('.action-btn.delete')) {
            const docId = target.dataset.id;
            if (confirm('Are you sure you want to delete this banner permanently?')) {
                setLoading(target, true);
                try {
                    await db.collection('banners').doc(docId).delete();
                    displayMessage(viewBannersMessage, 'Banner deleted successfully!', 'success');
                    await displayAllBanners();
                } catch (err) {
                    console.error("Error deleting banner:", err);
                    displayMessage(viewBannersMessage, `Error deleting banner: ${err.message}`, 'error');
                    setLoading(target, false);
                }
            }
        }
        if (target.matches('.action-btn.edit')) {
            await loadBannerForEditing(target.dataset.id);
        }
    });

    addEditBannerForm.addEventListener('submit', async e => {
        e.preventDefault();
        setLoading(saveBannerBtn, true);
        const id = bannerDocId.value;
        const data = {
            title: document.getElementById('bannerTitle').value.trim(),
            imageUrl: document.getElementById('bannerImageUrl').value,
            description: document.getElementById('bannerDescription').value,
            link: document.getElementById('bannerLink').value,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        };

        if (!data.title || !data.imageUrl || !data.link) {
            displayMessage(addBannerMessage, 'Title, Image URL, and Link are required for banners.', 'error');
            setLoading(saveBannerBtn, false);
            return;
        }

        try {
            if (id) {
                await db.collection('banners').doc(id).update(data);
            } else {
                await db.collection('banners').add({ ...data, createdAt: firebase.firestore.FieldValue.serverTimestamp() });
            }
            displayMessage(addBannerMessage, 'Banner saved successfully!', 'success');
            resetBannerForm();
            document.querySelector('.banner-tab-link[data-tab="viewBannersTab"]').click(); 
        } catch (err) {
            console.error("Error saving banner:", err);
            displayMessage(addBannerMessage, `Error saving banner: ${err.message}`, 'error');
        } finally {
            setLoading(saveBannerBtn, false);
        }
    });

    function resetBannerForm() {
        addEditBannerForm.reset();
        bannerDocId.value = '';
        bannerFormTitle.textContent = 'Add New Banner';
        saveBannerBtn.textContent = 'Save Banner';
        cancelEditBannerBtn.style.display = 'none';
        displayMessage(addBannerMessage, '', ''); 
    }
    cancelEditBannerBtn.addEventListener('click', resetBannerForm);

    async function loadBannerForEditing(id) {
        try {
            const doc = await db.collection('banners').doc(id).get();
            if (doc.exists) {
                const d = doc.data();
                bannerDocId.value = id;
                document.getElementById('bannerTitle').value = d.title || '';
                document.getElementById('bannerImageUrl').value = d.imageUrl || '';
                document.getElementById('bannerDescription').value = d.description || '';
                document.getElementById('bannerLink').value = d.link || '';
                bannerFormTitle.textContent = 'Editing Banner';
                saveBannerBtn.textContent = 'Update Banner';
                cancelEditBannerBtn.style.display = 'inline-block';
                document.querySelector('.banner-tab-link[data-tab="addBannerTab"]').click(); 
                window.scrollTo(0, 0);
            } else {
                displayMessage(addBannerMessage, 'Banner not found.', 'error');
            }
        } catch(err) {
            console.error("Error loading banner for editing:", err);
            displayMessage(addBannerMessage, 'Could not load banner for editing.', 'error');
        }
    }


    // --- User Management Logic ---
    userSearchBtn.addEventListener('click', async () => {
        const emailToSearch = userSearchEmailInput.value.trim();
        if (!emailToSearch) {
            displayUserMessage('Please enter an email to search.', 'error');
            return;
        }
        
        hideUserMessage();
        userEditFormSection.classList.add('hidden');
        userSearchBtn.disabled = true;
        userSearchBtn.textContent = 'Searching...';

        try {
            const usersRef = db.collection("users");
            const q = usersRef.where("email", "==", emailToSearch);
            const querySnapshot = await q.get();

            if (querySnapshot.empty) {
                displayUserMessage(`No user found with email: ${emailToSearch}. You can create a new document.`, 'info'); 
                clearUserForm();
                userEditEmailInput.value = emailToSearch;
                userFormTitle.textContent = "Create New User Document";
                userDocIdInput.value = "Will be auto-generated upon creation";
                userUpdateBtn.classList.add('hidden');
                userCreateBtn.classList.remove('hidden');
            } else {
                const userDoc = querySnapshot.docs[0];
                const userData = userDoc.data();
                displayUserMessage('User found. You can now edit the details below.', 'success');
                userDocIdInput.value = userDoc.id;
                userEditNameInput.value = userData.name || '';
                userEditEmailInput.value = userData.email || '';
                userEditActivatedSelect.value = userData.activated ? 'true' : 'false';
                userEditExpiresAtInput.value = formatTimestampForInput(userData.expiresAt);
                userFormTitle.textContent = "Edit User Document";
                userCreateBtn.classList.add('hidden');
                userUpdateBtn.classList.remove('hidden');
            }
            userEditFormSection.classList.remove('hidden');
            userFormDivider.classList.remove('hidden');
        } catch (error) {
            console.error("Error searching user: ", error);
            displayUserMessage(`An error occurred while searching: ${error.message}`, 'error');
        } finally {
            userSearchBtn.disabled = false;
            userSearchBtn.textContent = 'Search User';
        }
    });

    userUpdateBtn.addEventListener('click', async () => {
        const userId = userDocIdInput.value;
        if (!userId || userId === "Will be auto-generated upon creation") {
            displayUserMessage('No user document ID found. Please search for a user or use "Create New Document".', 'error');
            return;
        }
        userUpdateBtn.disabled = true;
        userUpdateBtn.textContent = 'Updating...';
        try {
            const userDocRef = db.collection("users").doc(userId);
            const dateValue = userEditExpiresAtInput.value ? new Date(userEditExpiresAtInput.value) : null;

            await userDocRef.update({
                name: userEditNameInput.value,
                email: userEditEmailInput.value,
                activated: userEditActivatedSelect.value === 'true',
                expiresAt: dateValue ? firebase.firestore.Timestamp.fromDate(dateValue) : null 
            });
            displayUserMessage('User document updated successfully!', 'success');
        } catch (error) {
            console.error("Error updating user document: ", error);
            displayUserMessage(`Failed to update document: ${error.message}`, 'error');
        } finally {
            userUpdateBtn.disabled = false;
            userUpdateBtn.textContent = 'Update Document';
        }
    });

    userCreateBtn.addEventListener('click', async () => {
        const email = userEditEmailInput.value.trim();
        const name = userEditNameInput.value.trim();
        if (!email || !name) {
            displayUserMessage('Email and Name are required to create a new document.', 'error');
            return;
        }
        userCreateBtn.disabled = true;
        userCreateBtn.textContent = 'Creating...';
        try {
            const newDocRef = db.collection("users").doc(); 
            const dateValue = userEditExpiresAtInput.value ? new Date(userEditExpiresAtInput.value) : null;

            await newDocRef.set({
                name: name,
                email: email,
                phone: "", 
                profileImage: "",
                activated: userEditActivatedSelect.value === 'true',
                expiresAt: dateValue ? firebase.firestore.Timestamp.fromDate(dateValue) : null,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                deleted: false
            });
            userDocIdInput.value = newDocRef.id;
            displayUserMessage(`New document created successfully with ID: ${newDocRef.id}`, 'success');
            userCreateBtn.classList.add('hidden');
            userUpdateBtn.classList.remove('hidden');
            userFormTitle.textContent = "Edit User Document"; 
        } catch (error) {
            console.error("Error creating user document: ", error);
            displayUserMessage(`Failed to create document: ${error.message}`, 'error');
        } finally {
            userCreateBtn.disabled = false;
            userCreateBtn.textContent = 'Create New Document';
        }
    });
});

    </script>

</body>
</html>
