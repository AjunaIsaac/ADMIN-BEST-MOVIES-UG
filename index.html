<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Panel (Multi-Project)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        :root {
            --primary-bg: #0b0f30;
            --secondary-bg: #121740;
            --accent-color: #d1e231;
            --text-color: #ffffff;
            --gradient-start: #ff006b;
            --gradient-mid: #FF9800;
            --gradient-end: #FFEB3B;
            --danger-color: #f44336;
            --success-color: #4CAF50;
            --info-color: #2196F3;
            --warn-color: #f39c12;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: Arial, sans-serif; background-color: var(--primary-bg); color: var(--text-color); display: flex; min-height: 100vh; overflow-x: hidden; flex-direction: column; } /* Adjusted to min-height and overflow-x hidden */

        /* Main Menu / Sidebar */
        #mainMenu {
            position: fixed; /* Keep fixed */
            top: 0;
            left: -260px; /* Default closed state */
            width: 250px;
            height: 100%;
            background-color: var(--secondary-bg);
            padding-top: 60px;
            transition: left 0.3s ease-in-out;
            z-index: 1100;
            border-right: 2px solid var(--accent-color);
            box-shadow: 5px 0 15px rgba(0,0,0,0.2);
        }
        #mainMenu.open { left: 0; } /* Open state */
        #mainMenu .menu-header { color: var(--accent-color); padding: 10px 20px; font-size: 1.5em; text-align: center; border-bottom: 1px solid #333; margin-bottom: 20px; }
        #mainMenu a { padding: 15px 20px; text-decoration: none; font-size: 18px; color: var(--text-color); display: flex; align-items: center; gap: 15px; transition: background-color 0.2s, color 0.2s; cursor: pointer; }
        #mainMenu a:hover { background-color: var(--primary-bg); }
        #mainMenu a.active { background-color: var(--accent-color); color: var(--primary-bg); font-weight: bold; }

        /* Menu Toggle Button */
        #menuToggleBtn {
            position: fixed;
            top: 15px; /* Adjusted for better visibility */
            left: 15px; /* Adjusted for better visibility */
            background: var(--secondary-bg);
            color: var(--accent-color);
            border: 1px solid var(--accent-color);
            border-radius: 5px;
            width: 50px;
            height: 50px;
            cursor: pointer;
            z-index: 1200;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        #menuToggleBtn:hover { background-color: var(--primary-bg); }

        /* Main Content Area */
        .main-content {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto;
            min-height: 100vh; /* Ensure it takes full height */
            transition: margin-left 0.3s ease-in-out;
            width: 100%;
            margin-left: 0; /* Default for closed menu/mobile */
        }

        /* Login Container */
        .login-container {
            background-color: var(--secondary-bg);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 400px;
            margin: 50px auto;
            text-align: center;
        }

        /* Page Containers */
        .page-container {
            display: none;
            background-color: var(--secondary-bg);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 800px;
            margin: 20px auto;
        }
        .page-container.active { display: block; }

        h1, h2 { text-align: center; color: var(--accent-color); margin-bottom: 20px; }

        /* Admin Header (Top bar) */
        .admin-header {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 10px 0;
            gap: 10px;
        }

        /* Logged in user email display */
        #adminEmailDisplay {
            font-size: 0.9em;
            color: #aaa;
            font-weight: normal;
            text-align: center;
            width: 100%;
            order: 3;
        }

        /* Logout Button */
        .logout-btn {
            background: var(--danger-color);
            width: auto;
            padding: 10px 15px;
            font-size: 14px;
            order: 2;
        }

        /* Form elements */
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 8px; font-weight: bold; }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 12px; border: 1px solid #333; border-radius: 5px; background-color: var(--primary-bg); color: var(--text-color); font-size: 16px; }
        .form-group input[readonly] { background-color: #2a2f50; cursor: not-allowed; opacity: 0.7; }
        .form-group input:focus, .form-group select:focus, .form-group textarea:focus { outline: none; border-color: var(--accent-color); }
        button { display: inline-block; width: 100%; padding: 15px; background: linear-gradient(45deg, var(--gradient-start), var(--gradient-mid), var(--gradient-end)); color: var(--text-color); border: none; border-radius: 5px; font-size: 18px; cursor: pointer; transition: transform 0.2s ease, opacity 0.2s; margin-top: 10px; position: relative; text-align: center; }
        button:hover { transform: translateY(-2px); opacity: 0.9; }
        button.loading { color: transparent !important; pointer-events: none; }
        button .spinner { display: none; border: 4px solid rgba(255, 255, 255, 0.3); border-top: 4px solid white; border-radius: 50%; width: 18px; height: 18px; animation: spin 1s linear infinite; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); }
        button.loading .spinner { display: block; }
        @keyframes spin { 0% { transform: translate(-50%, -50%) rotate(0deg); } 100% { transform: translate(-50%, -50%) rotate(360deg); } }
        .checkbox-group { display: flex; flex-wrap: wrap; gap: 10px 20px; background-color: var(--primary-bg); padding: 15px; border-radius: 5px; border: 1px solid #333; }
        .checkbox-group label { display: flex; align-items: center; gap: 8px; cursor: pointer; font-weight: normal; }
        .checkbox-group input[type="checkbox"] { height: 18px; width: 18px; cursor: pointer; }
        .message { margin-top: 20px; padding: 12px; border-radius: 5px; text-align: center; display: none; }
        .message.success { background-color: var(--success-color); }
        .message.error { background-color: var(--danger-color); }
        .message.info { background-color: var(--info-color); }
        .message.warn { background-color: var(--warn-color); } /* Added for warnings */
        .result-item { background-color: var(--primary-bg); padding: 10px; margin-bottom: 5px; border-radius: 5px; display: flex; flex-direction: column; align-items: flex-start; justify-content: space-between; gap: 10px; }
        .result-item span { text-align: left; width: 100%; }
        .result-item-actions { display: flex; flex-wrap: wrap; gap: 8px; width: 100%; justify-content: flex-start; }
        .action-btn { background-color: var(--accent-color) !important; color: var(--primary-bg) !important; padding: 8px 12px !important; border-radius: 5px !important; width: auto !important; font-size: 14px !important; margin-top: 0 !important; flex-grow: 1; min-width: 80px; }
        .action-btn.edit { background-color: var(--warn-color) !important; color: white !important; }
        .action-btn.delete { background-color: var(--danger-color) !important; color: white !important; }
        .action-btn.select-delete.selected { background-color: var(--success-color) !important; color: white !important; }
        .banner-nav-tabs { display: flex; flex-wrap: wrap; border-bottom: 1px solid var(--accent-color); margin-bottom: 20px; }
        .banner-tab-link { padding: 10px 15px; cursor: pointer; color: #aaa; border: none; background: none; font-size: 15px; flex-grow: 1; text-align: center; }
        .banner-tab-link.active { color: var(--accent-color); border-bottom: 2px solid var(--accent-color); font-weight: bold; }
        .banner-tab-content { display: none; }
        .banner-tab-content.active { display: block; }
        #allBannersContainer { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-top: 20px; }
        .banner-card { background-color: var(--primary-bg); border-radius: 8px; overflow: hidden; box-shadow: 0 4px 8px rgba(0,0,0,0.3); display: flex; flex-direction: column; }
        .banner-card img { width: 100%; height: 120px; object-fit: cover; background-color: #000; }
        .banner-card-content { padding: 10px; flex-grow: 1; display: flex; flex-direction: column; }
        .banner-card h3 { font-size: 1em; color: var(--accent-color); margin-bottom: 5px; text-align: left; }
        .banner-card p { font-size: 0.8em; color: #ccc; margin-bottom: 10px; flex-grow: 1; line-height: 1.4; }
        .banner-card-actions { display: flex; gap: 8px; margin-top: auto; border-top: 1px solid #333; padding-top: 8px; }
        .banner-card-actions .action-btn { width: 100% !important; flex: 1; }
        .banner-card-actions .action-btn.delete { background-color: var(--danger-color) !important; color: white !important; }

        /* Styles for User Management Section */
        #userManagementPage .input-group { margin-bottom: 15px; }
        #userManagementPage .input-group label { display: block; margin-bottom: 8px; color: #ccc; font-size: 14px; }
        #userManagementPage .input-group input, #userManagementPage .input-group select { width: 100%; padding: 10px; background: #222; border: 1px solid #444; border-radius: 8px; color: white; font-size: 15px; }
        #userManagementPage .btn-secondary { background: #555; }
        #userManagementPage hr { border-color: #444; margin: 20px 0; }

        /* NEW: Styles for All Content Page */
        .movie-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); /* Adjusted for more columns */
            gap: 20px;
            margin-top: 20px;
        }

        .content-card {
            background-color: var(--primary-bg);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            text-align: center;
            position: relative; /* For the checkbox */
        }

        .content-card img {
            width: 100%;
            height: 250px; /* Increased height for better visibility */
            object-fit: cover;
            background-color: #000;
            border-bottom: 1px solid #333;
        }

        .content-card-content {
            padding: 10px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Pushes buttons to bottom */
        }

        .content-card h3 {
            font-size: 1.1em;
            color: var(--accent-color);
            margin-bottom: 5px;
            white-space: nowrap; /* Prevent title from wrapping */
            overflow: hidden;
            text-overflow: ellipsis; /* Add ellipsis for long titles */
            padding: 0 5px; /* Add some padding */
        }

        .content-card p.vj-name {
            font-size: 0.8em;
            color: #ccc;
            margin-bottom: 10px;
            padding: 0 5px;
        }
        .content-card p.content-id-display,
        .content-card p.content-project-display {
            font-size: 0.75em;
            color: #999;
            margin-bottom: 3px;
        }

        .content-card-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px; /* Space from description */
            border-top: 1px solid #333;
            padding-top: 8px;
            justify-content: center; /* Center the buttons */
        }

        .content-card-actions .action-btn {
            flex: 1; /* Make buttons take equal space */
            min-width: unset; /* Override previous min-width */
            font-size: 0.9em !important;
            padding: 6px 10px !important;
        }

        .content-card input[type="checkbox"].select-card-checkbox {
            position: absolute;
            top: 8px;
            left: 8px;
            z-index: 10;
            width: 24px;
            height: 24px;
            cursor: pointer;
            background-color: rgba(0,0,0,0.5);
            border: 2px solid var(--accent-color);
            border-radius: 4px;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        .content-card input[type="checkbox"].select-card-checkbox:checked {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }

        .content-card input[type="checkbox"].select-card-checkbox:checked::before {
            content: '\2713'; /* Checkmark character */
            display: block;
            color: var(--primary-bg);
            font-size: 18px;
            line-height: 20px;
            text-align: center;
        }

        /* Styles for the new "For Sort Page Only" sections */
        .sort-page-section {
            margin-top: 30px;
            border-top: 1px solid #555;
            padding-top: 20px;
        }
        .sort-page-section h3 {
            color: var(--accent-color);
            margin-bottom: 15px;
            text-align: left;
        }

        /* --- Media Queries for Responsiveness --- */
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            #mainMenu {
                left: -260px; /* Keep it off-screen by default on small screens */
                width: 250px;
                padding-top: 80px; /* Make space for toggle button */
            }
            /* .open class will apply `left: 0` */

            #menuToggleBtn {
                position: fixed;
                top: 15px;
                left: 15px;
            }

            .main-content {
                margin-left: 0; /* No margin on small screens when menu is closed */
                padding: 15px;
                margin-top: 60px; /* Space for the fixed toggle button */
            }

            /* Adjust admin header for small screens */
            .admin-header {
                flex-direction: column;
                align-items: flex-start;
                margin-top: 0; /* Remove extra top margin as main-content now handles it */
            }
            #pageTitle {
                width: 100%;
                text-align: left;
                font-size: 1.8em;
                margin-bottom: 10px;
                order: 1;
            }
            #adminEmailDisplay {
                width: 100%;
                text-align: left;
                font-size: 0.8em;
                margin-bottom: 10px;
                order: 3;
            }
            .logout-btn {
                width: auto;
                order: 2;
                margin-left: auto;
                margin-top: -40px; /* Pull it up to sit next to the title if space allows */
            }

            .page-container {
                padding: 15px;
                margin: 15px auto;
            }

            .result-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            .result-item-actions {
                flex-direction: column;
                width: 100%;
            }
            .action-btn {
                width: 100% !important;
            }

            #allBannersContainer {
                grid-template-columns: 1fr;
            }
            .banner-card img {
                height: 100px;
            }
            .banner-card-content {
                padding: 8px;
            }
            .banner-card h3 {
                font-size: 0.9em;
            }
            .banner-card p {
                font-size: 0.75em;
            }
            .banner-tab-link {
                font-size: 14px;
                padding: 8px 10px;
            }

            /* NEW: All Content Page mobile adjustments */
            .movie-grid {
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
                gap: 15px;
            }
            .content-card img {
                height: 200px;
            }
            .content-card h3 {
                font-size: 1em;
            }
            .content-card p.vj-name {
                font-size: 0.7em;
            }
            .content-card-actions .action-btn {
                font-size: 0.8em !important;
                padding: 5px 8px !important;
            }
        }

        /* Desktop adjustments (min-width: 769px) */
        @media (min-width: 769px) {
            body {
                flex-direction: row; /* Main content and menu side-by-side */
            }

            #mainMenu {
                left: 0; /* Default open state on desktop */
                box-shadow: 5px 0 15px rgba(0,0,0,0.2); /* Re-add shadow for fixed menu */
            }

            #menuToggleBtn {
                top: 15px; /* Stay at top */
                left: calc(250px + 15px); /* Positioned relative to the open menu, +15px for spacing */
                transition: left 0.3s ease-in-out; /* Add transition for button too */
            }
            #mainMenu.open + #menuToggleBtn { /* When menu is open, move toggle button */
                left: calc(250px + 15px);
            }
            #mainMenu:not(.open) + #menuToggleBtn { /* When menu is NOT open, move toggle button back */
                left: 15px;
            }


            .main-content {
                margin-left: 250px; /* Space for the open sidebar */
                padding-top: 20px; /* Reset top padding from mobile */
            }

            /* Admin header for desktop */
            .admin-header {
                flex-direction: row;
                align-items: center;
                margin-top: 0;
            }
            #pageTitle {
                text-align: center;
                flex-grow: 1;
                order: initial;
            }
            #adminEmailDisplay {
                font-size: 14px;
                text-align: right;
                width: auto;
                margin-left: 20px;
                order: initial;
            }
            .logout-btn {
                width: auto;
                order: initial;
                margin-left: 15px;
                margin-top: 0;
            }
            
            .result-item {
                flex-direction: row;
                align-items: center;
            }
            .result-item-actions {
                flex-direction: row;
                width: auto;
            }
            .action-btn {
                width: auto !important;
            }
        }
    </style>
</head>
<body>

    <div id="loginScreen" class="main-content">
        <div class="login-container">
            <h1>Admin Login</h1>
            <form id="loginForm">
                <div class="form-group"><label for="loginEmail">Email</label><input type="email" id="loginEmail" required></div>
                <div class="form-group"><label for="loginPassword">Password</label><input type="password" id="loginPassword" required></div>
                <button type="submit">Login<span class="spinner"></span></button>
            </form>
            <div id="loginMessage" class="message"></div>
        </div>
    </div>

    <div id="adminPanel" style="display: none; width: 100%;">
        <button id="menuToggleBtn"><i class="fas fa-bars"></i></button>
<nav id="mainMenu">
    <div class="menu-header">Admin Menu</div>
    <a class="menu-link" data-page="addContentPage"><i class="fas fa-magic"></i> Add from TMDB</a>
    <a class="menu-link" data-page="manualAddPage"><i class="fas fa-edit"></i> Manual Add</a>
    <a class="menu-link" data-page="manageContentPage"><i class="fas fa-search"></i> Search & Edit/Delete</a>
    <a class="menu-link" data-page="allContentPage"><i class="fas fa-film"></i> All Content</a> 
    <a class="menu-link" data-page="bannerPage"><i class="fas fa-images"></i> Manage Banners</a>
    <a class="menu-link" data-page="userManagementPage"><i class="fas fa-users-cog"></i> User Management</a>
    <a class="https://cyber.follow256.com" href="https://cyber.follow256.com"><i class="fas fa-server"></i> My SERVER</a>
</nav>


        <div class="main-content" id="mainContentArea">
            <div class="admin-header">
                <h1 id="pageTitle"></h1>
                <span id="adminEmailDisplay" style="font-weight: normal;"></span>
                <button class="logout-btn" id="logoutBtn">Logout <i class="fas fa-sign-out-alt"></i></button>
            </div>

            <div id="addContentPage" class="page-container">
                <h2>Add Content from TMDB</h2>
                <form id="addMovieForm">
                    <div class="form-group"><label for="tmdbApiKey">TMDB API Key</label><input type="text" id="tmdbApiKey" value="7707eccc54e32b83ac790b5352c67ed3" readonly></div>
                    <div class="form-group"><label for="primaryContentType">Primary Content Type</label><select id="primaryContentType" class="primary-content-type-selector" required><option value="movie">Movie</option><option value="tv">TV Series</option></select></div>
                    <div class="form-group media-categories-group">
                        <label>Categories (Select all that apply)</label>
                        <div class="checkbox-group" id="contentTypeCheckboxes">
                            <label><input type="checkbox" name="contentType" value="latest_movies"> Latest Movies</label>
                            <label><input type="checkbox" name="contentType" value="latest_tv_shows"> Latest TV Shows</label>
                            <label><input type="checkbox" name="contentType" value="latest_uploads"> Latest Uploads</label>
                            <label><input type="checkbox" name="contentType" value="you_may_also_like"> You May Also Like</label>
                            <label><input type="checkbox" name="contentType" value="most_liked"> Most Liked</label>
                            <label><input type="checkbox" name="contentType" value="animation"> Animation</label>
                            <label><input type="checkbox" name="contentType" value="indian"> Indian</label>
                            <label><input type="checkbox" name="contentType" value="horror"> Horror</label>
                            <label><input type="checkbox" name="contentType" value="comedy"> Comedy</label>
                            <label><input type="checkbox" name="contentType" value="romance"> Romance</label>
                            <label><input type="checkbox" name="contentType" value="adventure"> Adventure</label>
                            <label><input type="checkbox" name="contentType" value="scifi-fantasy"> Sci-fi & Fantasy</label>
                            <label><input type="checkbox" name="contentType" value="action-thriller"> Action & Thriller</label>
                            <label><input type="checkbox" name="contentType" value="high-school"> High School</label>
                            <label><input type="checkbox" name="contentType" value="nigerian"> Nigerian Movies</label>
                            <label><input type="checkbox" name="contentType" value="upcoming_shows"> Upcoming Shows</label>
                            <label><input type="checkbox" name="contentType" value="western_series"> Western Series</label>
                            <label><input type="checkbox" name="contentType" value="asian_series"> Asian Series</label>
                            <label><input type="checkbox" name="contentType" value="k_dramas"> K Dramas</label>
                        </div>
                    </div>
                    <div class="form-group"><label for="contentIdentifier">Content Name or TMDB ID</label><input type="text" id="contentIdentifier" placeholder="e.g., The Matrix or TMDB ID 603" required></div>
                    <div class="form-group"><label for="vjName">VJ Name</label><input type="text" id="vjName" required></div>
                    <div class="form-group video-url-group"><label for="videoSourceUrl">Video Source URL</label><input type="url" id="videoSourceUrl" placeholder="e.g., https://example.com/video.mp4"></div>
                    <div class="form-group series-data-group" style="display: none;"><label for="seriesData">Series Data (JSON)</label><textarea id="seriesData" rows="8"></textarea></div>
                    
                    <hr class="sort-page-section" />
                    <div class="sort-page-section">
                        <h3>For Sort Page Only</h3>
                        <div class="form-group">
                            <label>VJs for Sort Page</label>
                            <div class="checkbox-group" id="sortVjsCheckboxesTMDB">
                                </div>
                        </div>
                        <div class="form-group">
                            <label>Genres for Sort Page</label>
                            <div class="checkbox-group" id="sortGenresCheckboxesTMDB">
                                </div>
                        </div>
                    </div>
                    <button type="submit" id="addContentBtn">Add Content<span class="spinner"></span></button>
                </form>
                <div id="addMessage" class="message"></div>
            </div>

            <div id="manualAddPage" class="page-container">
                <h2>Manually Add Content</h2>
                <form id="manualAddForm">
                    <div class="form-group"><label for="manualTitle">Title</label><input type="text" id="manualTitle" required></div>
                    <div class="form-group"><label for="manualOverview">Overview</label><textarea id="manualOverview" rows="4" required></textarea></div>
                    <div class="form-group"><label for="manualPosterUrl">Poster Image URL</label><input type="url" id="manualPosterUrl" required></div>
                    <div class="form-group"><label for="manualBackdropUrl">Backdrop Image URL</label><input type="url" id="manualBackdropUrl"></div>
                    <div class="form-group"><label for="manualVjName">VJ Name</label><input type="text" id="manualVjName" required></div>
                    <div class="form-group"><label for="manualPrimaryContentType">Primary Content Type</label><select id="manualPrimaryContentType" class="primary-content-type-selector" required><option value="movie">Movie</option><option value="tv">TV Series</option></select></div>
                    <div class="form-group media-categories-group">
                        <label>Categories</label>
                        <div class="checkbox-group" id="manualContentTypeCheckboxes">
                            <label><input type="checkbox" name="manualContentType" value="latest_movies"> Latest Movies</label>
                            <label><input type="checkbox" name="manualContentType" value="latest_tv_shows"> Latest TV Shows</label>
                            <label><input type="checkbox" name="manualContentType" value="latest_uploads"> Latest Uploads</label>
                            <label><input type="checkbox" name="manualContentType" value="you_may_also_like"> You May Also Like</label>
                            <label><input type="checkbox" name="manualContentType" value="most_liked"> Most Liked</label>
                            <label><input type="checkbox" name="manualContentType" value="animation"> Animation</label>
                            <label><input type="checkbox" name="manualContentType" value="indian"> Indian</label>
                            <label><input type="checkbox" name="manualContentType" value="horror"> Horror</label>
                            <label><input type="checkbox" name="manualContentType" value="comedy"> Comedy</label>
                            <label><input type="checkbox" name="manualContentType" value="romance"> Romance</label>
                            <label><input type="checkbox" name="manualContentType" value="adventure"> Adventure</label>
                            <label><input type="checkbox" name="manualContentType" value="scifi-fantasy"> Sci-fi & Fantasy</label>
                            <label><input type="checkbox" name="manualContentType" value="action-thriller"> Action & Thriller</label>
                            <label><input type="checkbox" name="manualContentType" value="high-school"> High School</label>
                            <label><input type="checkbox" name="manualContentType" value="nigerian"> Nigerian Movies</label>
                            <label><input type="checkbox" name="manualContentType" value="upcoming_shows"> Upcoming Shows</label>
                            <label><input type="checkbox" name="manualContentType" value="western_series"> Western Series</label>
                            <label><input type="checkbox" name="manualContentType" value="asian_series"> Asian Series</label>
                            <label><input type="checkbox" name="manualContentType" value="k_dramas"> K Dramas</label>
                        </div>
                    </div>

                    <div class="form-group genre-selection-group">
                        <label>Genres (Select all that apply)</label>
                        <div class="checkbox-group" id="manualGenreCheckboxes">
                            <label><input type="checkbox" name="manualGenre" value="action"> Action</label>
                            <label><input type="checkbox" name="manualGenre" value="adventure"> Adventure</label>
                            <label><input type="checkbox" name="manualGenre" value="animation"> Animation</label>
                            <label><input type="checkbox" name="manualGenre" value="comedy"> Comedy</label>
                            <label><input type="checkbox" name="manualGenre" value="crime"> Crime</label>
                            <label><input type="checkbox" name="manualGenre" value="documentary"> Documentary</label>
                            <label><input type="checkbox" name="manualGenre" value="drama"> Drama</label>
                            <label><input type="checkbox" name="manualGenre" value="family"> Family</label>
                            <label><input type="checkbox" name="manualGenre" value="fantasy"> Fantasy</label>
                            <label><input type="checkbox" name="manualGenre" value="history"> History</label>
                            <label><input type="checkbox" name="manualGenre" value="horror"> Horror</label>
                            <label><input type="checkbox" name="manualGenre" value="music"> Music</label>
                            <label><input type="checkbox" name="manualGenre" value="mystery"> Mystery</label>
                            <label><input type="checkbox" name="manualGenre" value="romance"> Romance</label>
                            <label><input type="checkbox" name="manualGenre" value="science-fiction"> Science Fiction</label>
                            <label><input type="checkbox" name="manualGenre" value="tv-movie"> TV Movie</label>
                            <label><input type="checkbox" name="manualGenre" value="thriller"> Thriller</label>
                            <label><input type="checkbox" name="manualGenre" value="war"> War</label>
                            <label><input type="checkbox" name="manualGenre" value="western"> Western</label>
                        </div>
                    </div>
                    <div class="form-group"><label for="manualReferenceId">Unique Text ID (e.g., mercy-for-none)</label><input type="text" id="manualReferenceId" placeholder="Enter a unique text identifier" required></div>

                    <div class="form-group video-url-group"><label for="manualVideoSourceUrl">Video Source URL</label><input type="url" id="manualVideoSourceUrl"></div>
                    <div class="form-group series-data-group" style="display: none;"><label for="manualSeriesData">Series Data (JSON)</label><textarea id="manualSeriesData" rows="8"></textarea></div>

                    <hr class="sort-page-section" />
                    <div class="sort-page-section">
                        <h3>For Sort Page Only</h3>
                        <div class="form-group">
                            <label>VJs for Sort Page</label>
                            <div class="checkbox-group" id="sortVjsCheckboxesManual">
                                </div>
                        </div>
                        <div class="form-group">
                            <label>Genres for Sort Page</label>
                            <div class="checkbox-group" id="sortGenresCheckboxesManual">
                                </div>
                        </div>
                    </div>
                    <button type="submit" id="manualAddContentBtn">Add Manually<span class="spinner"></span></button>
                </form>
                <div id="manualAddMessage" class="message"></div>
            </div>

            <div id="manageContentPage" class="page-container">
                <h2>Search & Manage Content</h2>
                <form id="manageContentForm">
                    <div class="form-group">
                        <label for="manageContentIdentifier">Search by Content Name, TMDB ID or Unique Text ID</label>
                        <input type="text" id="manageContentIdentifier" required>
                    </div>
                    <button type="button" id="searchManageBtn">Search Content<span class="spinner"></span></button>
                </form>
                <div id="manageSearchResults" style="margin-top: 20px;"></div>
                <button type="button" id="confirmDeleteBtn" style="display: none; background-color: var(--danger-color);">Delete Selected Content<span class="spinner"></span></button>
                <div id="manageMessage" class="message"></div>
            </div>

            <div id="allContentPage" class="page-container">
                <h2>All Available Content</h2>
                <div class="form-group">
                    <label for="allContentFilter">Filter by Category:</label>
                    <select id="allContentFilter">
                        <option value="all">All</option>
                        <option value="latest_movies">Latest Movies</option>
                        <option value="latest_tv_shows">Latest TV Shows</option>
                        <option value="latest_uploads">Latest Uploads</option>
                        <option value="you_may_also_like">You May Also Like</option>
                        <option value="most_liked">Most Liked</option>
                        <option value="animation">Animation</option>
                        <option value="indian">Indian</option>
                        <option value="horror">Horror</option>
                        <option value="comedy">Comedy</option>
                        <option value="romance">Romance</option>
                        <option value="adventure">Adventure</option>
                        <option value="scifi-fantasy">Sci-fi & Fantasy</option>
                        <option value="action-thriller">Action & Thriller</option>
                        <option value="high-school">High School</option>
                        <option value="nigerian">Nigerian Movies</option>
                        <option value="upcoming_shows">Upcoming Shows</option>
                        <option value="western_series">Western Series</option>
                        <option value="asian_series">Asian Series</option>
                        <option value="k_dramas">K Dramas</option>
                    </select>
                </div>
                <div id="allContentContainer" class="movie-grid"></div>
                <button type="button" id="deleteSelectedAllContentBtn" style="display: none; background-color: var(--danger-color); margin-top: 20px;">Delete Selected Content (<span id="selectedAllContentCount">0</span>)<span class="spinner"></span></button>
                <div id="allContentMessage" class="message"></div>
            </div>

            <div id="editContentPage" class="page-container">
                <h2>Edit Content</h2>
                <form id="editContentForm">
                    <input type="hidden" id="editDocId">
                    <div class="form-group"><label for="editTitle">Title</label><input type="text" id="editTitle" required></div>
                    <div class="form-group"><label for="editOverview">Overview</label><textarea id="editOverview" rows="4" required></textarea></div>
                    <div class="form-group"><label for="editPosterUrl">Poster Image URL</label><input type="url" id="editPosterUrl" required></div>
                    <div class="form-group"><label for="editBackdropUrl">Backdrop Image URL</label><input type="url" id="editBackdropUrl"></div>
                    <div class="form-group"><label for="editVjName">VJ Name</label><input type="text" id="editVjName" required></div>
                    <div class="form-group"><label for="editPrimaryContentType">Primary Content Type</label><select id="editPrimaryContentType" class="primary-content-type-selector" required><option value="movie">Movie</option><option value="tv">TV Series</option></select></div>
                    <div class="form-group media-categories-group">
                        <label>Categories</label>
                        <div class="checkbox-group" id="editContentTypeCheckboxes">
                            <label><input type="checkbox" name="editContentType" value="latest_movies"> Latest Movies</label>
                            <label><input type="checkbox" name="editContentType" value="latest_tv_shows"> Latest TV Shows</label>
                            <label><input type="checkbox" name="editContentType" value="latest_uploads"> Latest Uploads</label>
                            <label><input type="checkbox" name="editContentType" value="you_may_also_like"> You May Also Like</label>
                            <label><input type="checkbox" name="editContentType" value="most_liked"> Most Liked</label>
                            <label><input type="checkbox" name="editContentType" value="animation"> Animation</label>
                            <label><input type="checkbox" name="editContentType" value="indian"> Indian</label>
                            <label><input type="checkbox" name="editContentType" value="horror"> Horror</label>
                            <label><input type="checkbox" name="editContentType" value="comedy"> Comedy</label>
                            <label><input type="checkbox" name="editContentType" value="romance"> Romance</label>
                            <label><input type="checkbox" name="editContentType" value="adventure"> Adventure</label>
                            <label><input type="checkbox" name="editContentType" value="scifi-fantasy"> Sci-fi & Fantasy</label>
                            <label><input type="checkbox" name="editContentType" value="action-thriller"> Action & Thriller</label>
                            <label><input type="checkbox" name="editContentType" value="high-school"> High School</label>
                            <label><input type="checkbox" name="editContentType" value="nigerian"> Nigerian Movies</label>
                            <label><input type="checkbox" name="editContentType" value="upcoming_shows"> Upcoming Shows</label>
                            <label><input type="checkbox" name="editContentType" value="western_series"> Western Series</label>
                            <label><input type="checkbox" name="editContentType" value="asian_series"> Asian Series</label>
                            <label><input type="checkbox" name="editContentType" value="k_dramas"> K Dramas</label>
                        </div>
                    </div>

                    <div class="form-group genre-selection-group">
                        <label>Genres (Select all that apply)</label>
                        <div class="checkbox-group" id="editGenreCheckboxes">
                            <label><input type="checkbox" name="editGenre" value="action"> Action</label>
                            <label><input type="checkbox" name="editGenre" value="adventure"> Adventure</label>
                            <label><input type="checkbox" name="editGenre" value="animation"> Animation</label>
                            <label><input type="checkbox" name="editGenre" value="comedy"> Comedy</label>
                            <label><input type="checkbox" name="editGenre" value="crime"> Crime</label>
                            <label><input type="checkbox" name="editGenre" value="documentary"> Documentary</label>
                            <label><input type="checkbox" name="editGenre" value="drama"> Drama</label>
                            <label><input type="checkbox" name="editGenre" value="family"> Family</label>
                            <label><input type="checkbox" name="editGenre" value="fantasy"> Fantasy</label>
                            <label><input type="checkbox" name="editGenre" value="history"> History</label>
                            <label><input type="checkbox" name="editGenre" value="horror"> Horror</label>
                            <label><input type="checkbox" name="editGenre" value="music"> Music</label>
                            <label><input type="checkbox" name="editGenre" value="mystery"> Mystery</label>
                            <label><input type="checkbox" name="editGenre" value="romance"> Romance</label>
                            <label><input type="checkbox" name="editGenre" value="science-fiction"> Science Fiction</label>
                            <label><input type="checkbox" name="editGenre" value="tv-movie"> TV Movie</label>
                            <label><input type="checkbox" name="editGenre" value="thriller"> Thriller</label>
                            <label><input type="checkbox" name="editGenre" value="war"> War</label>
                            <label><input type="checkbox" name="editGenre" value="western"> Western</label>
                        </div>
                    </div>
                    <div class="form-group"><label for="editReferenceId">Reference ID (TMDB or Custom Text)</label><input type="text" id="editReferenceId" placeholder="TMDB ID or your unique text ID"></div>

                    <div class="form-group video-url-group"><label for="editVideoSourceUrl">Video Source URL</label><input type="url" id="editVideoSourceUrl"></div>
                    <div class="form-group series-data-group" style="display: none;"><label for="editSeriesData">Series Data (JSON)</label><textarea id="editSeriesData" rows="8"></textarea></div>

                    <hr class="sort-page-section" />
                    <div class="sort-page-section">
                        <h3>For Sort Page Only</h3>
                        <div class="form-group">
                            <label>VJs for Sort Page</label>
                            <div class="checkbox-group" id="sortVjsCheckboxesEdit">
                                </div>
                        </div>
                        <div class="form-group">
                            <label>Genres for Sort Page</label>
                            <div class="checkbox-group" id="sortGenresCheckboxesEdit">
                                </div>
                        </div>
                    </div>
                    <button type="submit" id="updateContentBtn">Update Content<span class="spinner"></span></button>
                    <button type="button" id="cancelEditBtn" style="background-color: gray; margin-top: 10px;">Cancel Edit</button>
                </form>
                <div id="editMessage" class="message"></div>
            </div>

            <div id="bannerPage" class="page-container">
                <div class="banner-nav-tabs">
                    <button class="banner-tab-link" data-tab="viewBannersTab">View All Banners</button>
                    <button class="banner-tab-link" data-tab="addBannerTab">Add/Edit Banner</button>
                </div>
                
                <div id="addBannerTab" class="banner-tab-content">
                    <h2 id="bannerFormTitle">Add New Banner</h2>
                    <form id="addEditBannerForm">
                        <input type="hidden" id="bannerDocId">
                        <div class="form-group"><label for="bannerTitle">Banner Title</label><input type="text" id="bannerTitle" required></div>
                        <div class="form-group"><label for="bannerImageUrl">Image URL</label><input type="text" id="bannerImageUrl" required></div>
                        <div class="form-group"><label for="bannerDescription">Description</label><textarea id="bannerDescription" rows="3"></textarea></div>
                        <div class="form-group"><label for="bannerLink">"Watch Now" Link</label><input type="text" id="bannerLink" required></div>
                        <button type="submit" id="saveBannerBtn">Save Banner<span class="spinner"></span></button>
                        <button type="button" id="cancelEditBannerBtn" style="display:none; background: gray;">Cancel Edit / New</button>
                    </form>
                    <div id="addBannerMessage" class="message"></div>
                </div>

                <div id="viewBannersTab" class="banner-tab-content">
                    <h2>All Available Banners</h2>
                    <div id="allBannersContainer"></div>
                    <div id="viewBannersMessage" class="message"></div>
                </div>
            </div>

            <div id="userManagementPage" class="page-container">
                <h2>User Management Panel</h2>
                
                <div class="input-group">
                    <label for="user-search-email">Search User by Email</label>
                    <input type="email" id="user-search-email" placeholder="user@example.com" />
                </div>
                <button class="btn" id="user-search-btn">Search User</button>

                <div id="user-message-area" class="message hidden"></div>
                <hr class="hidden" id="user-form-divider" />

                <div id="user-edit-form-section" class="hidden">
                    <h3 id="user-form-title">Edit User</h3>
                    <div class="input-group"><label for="user-doc-id">Document ID (User UID)</label><input type="text" id="user-doc-id" disabled /></div>
                    <div class="input-group"><label for="user-edit-name">Full Name</label><input type="text" id="user-edit-name" /></div>
                    <div class="input-group"><label for="user-edit-email">Email</label><input type="email" id="user-edit-email" /></div>
                    <div class="input-group"><label for="user-edit-activated">Account Activated</label><select id="user-edit-activated"><option value="true">True</option><option value="false">False</option></select></div>
                    <div class="input-group"><label for="user-edit-expiresAt">Subscription Expiration</label><input type="datetime-local" id="user-edit-expiresAt" /></div>
                    <button class="btn" id="user-update-btn">Update Document</button>
                    <button class="btn btn-secondary" id="user-create-btn">Create New Document</button>
                </div>
            </div>

        </div>
    </div>
    
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
    
   <script>
    document.addEventListener('DOMContentLoaded', () => {
    // --- Firebase Configurations ---
    const primaryFirebaseConfig = {
        apiKey: "AIzaSyAn2vbkT9yjyWtJzNSHgRureco5gEjYd_Q",
        authDomain: "stream-zone-movies-a83c1.firebaseapp.com",
        projectId: "stream-zone-movies-a83c1",
        storageBucket: "stream-zone-movies-a83c1.appspot.com",
        messagingSenderId: "148342664213",
        appId: "1:148342664213:web:56df2549cc480df7cf721c"
    };

    const secondary1FirebaseConfig = {
        apiKey: "AIzaSyCQhwMc1uYLmjLMmBWk5QpT3XcLsuzBIEQ",
        authDomain: "reyikingtv1.firebaseapp.com",
        projectId: "reyikingtv1",
        storageBucket: "reyikingtv1.firebaseapp.com",
        messagingSenderId: "617666017039",
        appId: "1:617666017039:web:5fa4ce795d9a0da0cfb07a"
    };

    const secondary2FirebaseConfig = {
        apiKey: "AIzaSyCgbaRR6ezvswehl1Q21ICHgBtXZ9bcLwA",
        authDomain: "my-movies-admin.firebaseapp.com",
        projectId: "my-movies-admin",
        storageBucket: "my-movies-admin.appspot.com",
        messagingSenderId: "492775126123",
        appId: "1:492775126123:web:7ad51095ff15f61ed12d2e"
    };

    // --- Initialize Firebase Apps ---
    const app = firebase.initializeApp(primaryFirebaseConfig);
    const db = firebase.firestore(app);
    const auth = firebase.auth(app);
    const secondaryApp1 = firebase.initializeApp(secondary1FirebaseConfig, 'reyikingtv1');
    const db1 = firebase.firestore(secondaryApp1);
    const secondaryApp2 = firebase.initializeApp(secondary2FirebaseConfig, 'my-movies-admin');
    const db2 = firebase.firestore(secondaryApp2);
    const dbsToCheck = [ 
        { name: primaryFirebaseConfig.projectId, instance: db }, 
        { name: secondary1FirebaseConfig.projectId, instance: db1 }, 
        { name: secondary2FirebaseConfig.projectId, instance: db2 } 
    ];
    
    // --- DOM Element References ---
    const loginScreen = document.getElementById('loginScreen');
    const adminPanel = document.getElementById('adminPanel');
    const mainMenu = document.getElementById('mainMenu');
    const menuToggleBtn = document.getElementById('menuToggleBtn');
    const pageTitle = document.getElementById('pageTitle');
    const adminEmailDisplay = document.getElementById('adminEmailDisplay'); 
    const logoutBtn = document.getElementById('logoutBtn');
    const loginMessage = document.getElementById('loginMessage');
    const mainContentArea = document.getElementById('mainContentArea'); 

    // Content Management Elements
    const addMovieForm = document.getElementById('addMovieForm');
    const addContentBtn = document.getElementById('addContentBtn');
    const addMessage = document.getElementById('addMessage');
    const manualAddForm = document.getElementById('manualAddForm');
    const manualAddBtn = document.getElementById('manualAddContentBtn');
    const manualAddMessage = document.getElementById('manualAddMessage');
    const searchManageBtn = document.getElementById('searchManageBtn');
    const manageSearchResults = document.getElementById('manageSearchResults');
    const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');
    const manageMessage = document.getElementById('manageMessage');
    const editContentForm = document.getElementById('editContentForm');
    const updateContentBtn = document.getElementById('updateContentBtn');
    const editMessage = document.getElementById('editMessage');
    const cancelEditBtn = document.getElementById('cancelEditBtn');

    // Banner Management Elements
    const bannerNavTabs = document.querySelector('.banner-nav-tabs');
    const addEditBannerForm = document.getElementById('addEditBannerForm');
    const bannerFormTitle = document.getElementById('bannerFormTitle');
    const bannerDocId = document.getElementById('bannerDocId');
    const saveBannerBtn = document.getElementById('saveBannerBtn');
    const cancelEditBannerBtn = document.getElementById('cancelEditBannerBtn');
    const addBannerMessage = document.getElementById('addBannerMessage');
    const allBannersContainer = document.getElementById('allBannersContainer');
    const viewBannersMessage = document.getElementById('viewBannersMessage');
    let selectedMoviesForDeletion = new Set(); // For manageContentPage search results

    // User Management Elements
    const userSearchEmailInput = document.getElementById('user-search-email');
    const userSearchBtn = document.getElementById('user-search-btn');
    const userMessageArea = document.getElementById('user-message-area');
    const userEditFormSection = document.getElementById('user-edit-form-section');
    const userFormDivider = document.getElementById('user-form-divider');
    const userDocIdInput = document.getElementById('user-doc-id');
    const userEditNameInput = document.getElementById('user-edit-name');
    const userEditEmailInput = document.getElementById('user-edit-email');
    const userEditActivatedSelect = document.getElementById('user-edit-activated');
    const userEditExpiresAtInput = document.getElementById('user-edit-expiresAt');
    const userUpdateBtn = document.getElementById('user-update-btn');
    const userCreateBtn = document.getElementById('user-create-btn');
    const userFormTitle = document.getElementById('user-form-title'); 

    // All Content Page Elements
    const allContentContainer = document.getElementById('allContentContainer');
    const allContentMessage = document.getElementById('allContentMessage');
    const allContentFilter = document.getElementById('allContentFilter');
    const deleteSelectedAllContentBtn = document.getElementById('deleteSelectedAllContentBtn');
    const selectedAllContentCount = document.getElementById('selectedAllContentCount');
    let selectedAllContentForDeletion = new Set();

    // NEW: VJ and Genre Lists for Sort Page
    const VJ_LIST = [
        "Vj Junior", "Vj Emmy", "VJ Nelly", "Vj Jovan", "Vj Tom", "Vj Shao Khan", "Vj Jingo", "Vj Ice P", "Vj Kevo",
        "Vj Kevin", "Vj Kriss Sweet", "Vj Hd", "Vj Dan De", "Vj Sammy", "Vj Ivo", "Vj Isma K", "Vj Little T", "Vj Mox",
        "Vj Muba", "Vj Eddy", "Vj Kam", "Vj Lance", "Vj KS", "Vj Ulio", "Vj Aaron", "Vj Cabs", "Vj Banks", "Vj Jimmy",
        "Vj Baros", "Vj Kimuli", "Vj Fredy", "Vj Jumpers", "Vj Ashim", "Vj Pauleta", "Vj Martin K", "Vj Henrico", "Vj Uncle T"
    ];
    const GENRE_LIST = [
        "Action", "Horror", "Series", "Adventure", "Love Story", "Comedy", "Crime", "Family", "Sci FI", "Romance",
        "Kungu Fu", "Drama", "Sport", "Thriller", "Animation", "Documentary", "Fantasy", "History", "Music", "Mystery",
        "War", "Western"
    ];

    // Function to populate checkbox groups
    function populateCheckboxes(containerId, namePrefix, list, selectedValues = []) {
        const container = document.getElementById(containerId);
        if (!container) return; // Ensure container exists
        container.innerHTML = ''; // Clear existing checkboxes

        list.forEach(item => {
            const label = document.createElement('label');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.name = namePrefix;
            checkbox.value = item;
            checkbox.checked = selectedValues.includes(item); // Pre-select if in selectedValues

            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(` ${item}`));
            container.appendChild(label);
        });
    }

    // Populate all sort page checkbox groups on DOMContentLoaded
    populateCheckboxes('sortVjsCheckboxesTMDB', 'sortVjsTMDB', VJ_LIST);
    populateCheckboxes('sortGenresCheckboxesTMDB', 'sortGenresTMDB', GENRE_LIST);
    populateCheckboxes('sortVjsCheckboxesManual', 'sortVjsManual', VJ_LIST);
    populateCheckboxes('sortGenresCheckboxesManual', 'sortGenresManual', GENRE_LIST);
    populateCheckboxes('sortVjsCheckboxesEdit', 'sortVjsEdit', VJ_LIST);
    populateCheckboxes('sortGenresCheckboxesEdit', 'sortGenresEdit', GENRE_LIST);


    // --- Helper Functions ---
    function setLoading(button, isLoading) {
        if(button) {
            button.classList.toggle('loading', isLoading);
            button.disabled = isLoading;
        }
    }

    function displayMessage(element, msg, type) {
        if (element) {
            element.textContent = msg;
            element.className = `message ${type}`;
            element.style.display = 'block';
            setTimeout(() => { element.style.display = 'none'; }, 8000);
        }
    }
    
    function generateSlug(text) {
        if (!text) return '';
        return text
            .toString()
            .toLowerCase()
            .trim()
            .replace(/\s+/g, '-')
            .replace(/[^\w\-]+/g, '')
            .replace(/\-\-+/g, '-');
    }

    async function checkForDuplicates(payload, excludeDocId = null, currentProject = primaryFirebaseConfig.projectId) {
        // Check for duplicate TMDB ID if it exists and is a number
        if (payload.tmdbId && typeof payload.tmdbId === 'number') {
            for (const dbInfo of dbsToCheck) {
                const q = dbInfo.instance.collection('movies').where('tmdbId', '==', payload.tmdbId);
                const snapshot = await q.get();
                for (const doc of snapshot.docs) {
                    // Exclude self if checking within the same project's database
                    if (!(dbInfo.name === currentProject && doc.id === excludeDocId)) {
                        return { found: true, project: dbInfo.name, field: 'TMDB ID' };
                    }
                }
            }
        }

        // Check for duplicate slug
        if (payload.slug) {
            for (const dbInfo of dbsToCheck) {
                const q = dbInfo.instance.collection('movies').where('slug', '==', payload.slug);
                const snapshot = await q.get();
                for (const doc of snapshot.docs) {
                    // Exclude self if checking within the same project's database
                    if (!(dbInfo.name === currentProject && doc.id === excludeDocId)) {
                        return { found: true, project: dbInfo.name, field: 'Unique Text ID (slug)' };
                    }
                }
            }
        }
        return { found: false, project: null, field: null };
    }

    // User Management specific helper functions
    function hideUserMessage() { userMessageArea.classList.add('hidden'); }
    function clearUserForm() {
        userDocIdInput.value = '';
        userEditNameInput.value = '';
        userEditEmailInput.value = '';
        userEditActivatedSelect.value = 'true';
        userEditExpiresAtInput.value = '';
        userEditFormSection.classList.add('hidden');
        userFormDivider.classList.add('hidden');
        hideUserMessage();
    }
    function formatTimestampForInput(timestamp) {
        if (!timestamp || typeof timestamp.toDate !== 'function') return '';
        const date = timestamp.toDate();
        const timezoneOffset = date.getTimezoneOffset() * 60000;
        const localDate = new Date(date.getTime() - timezoneOffset);
        return localDate.toISOString().slice(0, 16);
    }
    function displayUserMessage(text, type = 'success') {
        userMessageArea.textContent = text;
        userMessageArea.className = `message ${type}`;
        userMessageArea.classList.remove('hidden');
    }


    // --- Auth and Navigation ---
    auth.onAuthStateChanged(user => {
        loginScreen.style.display = user ? 'none' : 'flex';
        adminPanel.style.display = user ? 'flex' : 'none';
        
        if(user) {
            adminEmailDisplay.textContent = `Logged in as: ${user.email}`;
            // Set initial menu state based on screen size
            if (window.innerWidth >= 769) {
                mainMenu.classList.add('open'); // Open by default on desktop
                mainContentArea.style.marginLeft = '250px';
                menuToggleBtn.style.left = '265px'; // Positioned next to opened menu
            } else {
                mainMenu.classList.remove('open'); // Closed by default on mobile
                mainContentArea.style.marginLeft = '0';
                menuToggleBtn.style.left = '15px'; // Default mobile position
            }
            menuToggleBtn.style.display = 'flex'; // Ensure button is always visible when logged in
            navigateToPage('addContentPage'); // Default page after login
        } else {
            adminEmailDisplay.textContent = '';
            menuToggleBtn.style.display = 'none'; // Hide toggle button when not logged in
        }
    });

    document.getElementById('loginForm').addEventListener('submit', async e => {
        e.preventDefault();
        const btn = e.target.querySelector('button');
        setLoading(btn, true);
        try {
            await auth.signInWithEmailAndPassword(document.getElementById('loginEmail').value, document.getElementById('loginPassword').value);
            displayMessage(loginMessage, '', ''); // Clear any previous login message
        } catch (error) {
            displayMessage(loginMessage, 'Invalid credentials.', 'error');
        } finally {
            setLoading(btn, false);
        }
    });

    logoutBtn.addEventListener('click', () => auth.signOut());
    
    menuToggleBtn.addEventListener('click', () => {
        mainMenu.classList.toggle('open');
        if (mainMenu.classList.contains('open')) {
            mainContentArea.style.marginLeft = '250px';
            menuToggleBtn.style.left = '265px'; // Move button with menu
        } else {
            mainContentArea.style.marginLeft = '0';
            menuToggleBtn.style.left = '15px'; // Move button back
        }
    });

    function navigateToPage(pageId) {
        document.querySelectorAll('.page-container').forEach(p => p.classList.remove('active'));
        const page = document.getElementById(pageId);
        if (page) {
            page.classList.add('active');
            if (pageId === 'bannerPage') {
                const viewBannersTabLink = document.querySelector('.banner-tab-link[data-tab="viewBannersTab"]');
                if (viewBannersTabLink) {
                    viewBannersTabLink.click();
                }
            } else if (pageId === 'allContentPage') { 
                displayAllContent();
            }
        }
        document.querySelectorAll('.menu-link').forEach(link => {
            const isActive = link.dataset.page === pageId;
            link.classList.toggle('active', isActive);
            if (isActive) pageTitle.textContent = link.textContent.trim();
        });
        // On mobile, automatically close menu after navigating
        if (window.innerWidth < 769) { 
            mainMenu.classList.remove('open');
            mainContentArea.style.marginLeft = '0'; 
            menuToggleBtn.style.left = '15px'; 
        }
        window.scrollTo(0, 0);
    }
    document.querySelectorAll('.menu-link').forEach(link => {
        link.addEventListener('click', (e) => {
            e.preventDefault();
            navigateToPage(e.currentTarget.dataset.page);
        });
    });

    // Handle window resize for menu state
    window.addEventListener('resize', () => {
        if (auth.currentUser) { // Only adjust if logged in
            if (window.innerWidth >= 769) {
                mainMenu.classList.add('open');
                mainContentArea.style.marginLeft = '250px';
                menuToggleBtn.style.left = '265px';
            } else {
                mainMenu.classList.remove('open');
                mainContentArea.style.marginLeft = '0';
                menuToggleBtn.style.left = '15px';
            }
        }
    });


    function setupMasterContentTypeToggle(formElement) {
        const primarySelector = formElement.querySelector('.primary-content-type-selector');
        const mediaCategoriesGroup = formElement.querySelector('.media-categories-group');
        const videoUrlGroup = formElement.querySelector('.video-url-group');
        const seriesDataGroup = formElement.querySelector('.series-data-group');
        const genreSelectionGroup = formElement.querySelector('.genre-selection-group'); // Get genre group

        // Define movie and TV series categories
        // Renamed 'movie' to 'latest_movies' for consistency with request
        // Renamed 'tv' to 'latest_tv_shows' for consistency with request
        // Renamed 'popular' to 'latest_uploads'
        const movieCategories = [
            'latest_movies', 'latest_uploads', 'you_may_also_like', 'most_liked', 'animation', 'indian', 'horror', 'comedy', 'romance', 
            'adventure', 'scifi-fantasy', 'action-thriller', 'high-school', 'nigerian'
        ];
        const tvCategories = [
            'latest_tv_shows', 'latest_uploads', 'you_may_also_like', 'most_liked',
            'upcoming_shows', 'western_series', 'asian_series', 'k_dramas'
        ];

        function toggleFields() {
            const primaryType = primarySelector.value;
            const isTV = primaryType === 'tv';

            // Show/hide the entire categories group based on primary type
            if(mediaCategoriesGroup) mediaCategoriesGroup.style.display = 'block'; 

            // Iterate through all checkboxes within the categories group and set their display style
            const categoriesCheckboxes = mediaCategoriesGroup.querySelectorAll('input[type="checkbox"]');
            categoriesCheckboxes.forEach(checkbox => {
                const categoryValue = checkbox.value;
                const parentLabel = checkbox.parentElement; // The <label> element wrapping the checkbox

                if (isTV) {
                    // If TV series is selected, show only TV-specific categories
                    parentLabel.style.display = tvCategories.includes(categoryValue) ? 'flex' : 'none';
                } else {
                    // If Movie is selected, show only movie-specific categories
                    parentLabel.style.display = movieCategories.includes(categoryValue) ? 'flex' : 'none';
                }
            });

            // Genre selection group is always visible, as genres apply to both movies and TV.
            if (genreSelectionGroup) genreSelectionGroup.style.display = 'block'; // Ensure it's always visible

            if(videoUrlGroup) videoUrlGroup.style.display = isTV ? 'none' : 'block';
            if(seriesDataGroup) seriesDataGroup.style.display = isTV ? 'block' : 'none';
        }

        if(primarySelector) {
            primarySelector.addEventListener('change', toggleFields);
            // Call immediately to set initial state based on default selected option
            toggleFields(); 
        }
    }
    setupMasterContentTypeToggle(document.getElementById('addMovieForm'));
    setupMasterContentTypeToggle(document.getElementById('manualAddForm'));
    setupMasterContentTypeToggle(document.getElementById('editContentForm'));


    // --- TMDB Add Form Logic ---
    addMovieForm.addEventListener('submit', async e => {
        e.preventDefault();
        setLoading(addContentBtn, true);
        const primaryType = document.getElementById('primaryContentType').value;
        const isTV = primaryType === 'tv';
        const identifier = document.getElementById('contentIdentifier').value.trim();
        const vjName = document.getElementById('vjName').value.trim();
        const tmdbApiKey = document.getElementById('tmdbApiKey').value;
        const apiType = isTV ? 'tv' : 'movie';

        if (!vjName) {
            displayMessage(addMessage, 'VJ Name is required.', 'error');
            setLoading(addContentBtn, false);
            return;
        }

        const tmdbData = await (async (id, key) => {
            const isId = /^\d+$/.test(id);
            // Fetch both general data and then configuration for image base URL
            const url = isId ? `https://api.themoviedb.org/3/${apiType}/${id}?api_key=${key}` : `https://api.themoviedb.org/3/search/${apiType}?api_key=${key}&query=${encodeURIComponent(id)}`;
            try {
                const r = await fetch(url);
                if (!r.ok) {
                    console.error(`TMDB API error: ${r.status} ${r.statusText}`);
                    return null;
                }
                const d = await r.json();
                const fetchedData = isId ? d : (d.results?.[0] || null);

                if (fetchedData) {
                    const configUrl = `https://api.themoviedb.org/3/configuration?api_key=${key}`;
                    const configResponse = await fetch(configUrl);
                    const configData = await configResponse.json();
                    const baseImageUrl = configData.images.base_url + configData.images.poster_sizes[3]; // w500 for poster
                    const baseBackdropUrl = configData.images.base_url + configData.images.backdrop_sizes[2]; // w780 for backdrop

                    fetchedData.fullPosterPath = fetchedData.poster_path ? `${baseImageUrl}${fetchedData.poster_path}` : '';
                    fetchedData.fullBackdropPath = fetchedData.backdrop_path ? `${baseBackdropUrl}${fetchedData.backdrop_path}` : '';
                }
                return fetchedData;
            } catch (err) {
                console.error("Error fetching from TMDB:", err);
                return null;
            }
        })(identifier, tmdbApiKey);

        if (!tmdbData || !tmdbData.id) {
            displayMessage(addMessage, 'Could not find content on TMDB. Check name/ID or API key.', 'error');
            setLoading(addContentBtn, false);
            return;
        }

        const finalTitle = tmdbData.title || tmdbData.name;
        let payload = {
            title: finalTitle,
            tmdbId: tmdbData.id,
            slug: generateSlug(finalTitle), // Slug based on TMDB title
            posterUrl: tmdbData.fullPosterPath || '', // Use the full path
            backdropUrl: tmdbData.fullBackdropPath || '', // Add backdrop URL
            overview: tmdbData.overview || "N/A",
            vjName: vjName,
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            addedBy: auth.currentUser.email
        };

        // TMDB fetched genres (if available, TMDB has genres as numbers)
        // You might need a mapping here if you want string genres for TMDB items.
        // For simplicity, we'll store TMDB's genre_ids directly or leave empty if not applicable.
        // TMDB typically returns genre_ids, which are numeric. If you want readable strings,
        // you'd need to fetch TMDB's genre list and map them. For now, it will be numeric IDs.
        payload.genres = tmdbData.genre_ids || [];

        if (isTV) {
            payload.contentType = 'tv';
            // For TV, 'type' will store the selected TV categories
            const selectedTypes = Array.from(document.querySelectorAll('#contentTypeCheckboxes input[name="contentType"]:checked')).map(cb => cb.value);
            if(selectedTypes.length === 0) {
                displayMessage(addMessage, 'Please select at least one category for TV series.', 'error');
                setLoading(addContentBtn, false);
                return;
            }
            payload.type = selectedTypes;
            try {
                const seriesDataValue = document.getElementById('seriesData').value;
                if(!seriesDataValue) {
                    displayMessage(addMessage, "Series Data (JSON) cannot be empty for TV series.", 'error');
                    setLoading(addContentBtn, false);
                    return;
                }
                payload.seriesInfo = JSON.parse(seriesDataValue);
            } catch (err) {
                displayMessage(addMessage, `Invalid JSON in Series Data: ${err.message}`, 'error');
                setLoading(addContentBtn, false);
                return;
            }
        } else { 
            payload.contentType = 'movie';
            // For movies, 'type' will store the selected movie categories
            const selectedTypes = Array.from(document.querySelectorAll('#contentTypeCheckboxes input[name="contentType"]:checked')).map(cb => cb.value);
            if(selectedTypes.length === 0) {
                displayMessage(addMessage, 'Please select at least one category for movies.', 'error');
                setLoading(addContentBtn, false);
                return;
            }
            payload.type = selectedTypes;
            payload.videoUrl = document.getElementById('videoSourceUrl').value;
        }

        // NEW: Collect values for sort_vjs and sort_genres
        payload.sort_vjs = Array.from(document.querySelectorAll('#sortVjsCheckboxesTMDB input[name="sortVjsTMDB"]:checked')).map(cb => cb.value);
        payload.sort_genres = Array.from(document.querySelectorAll('#sortGenresCheckboxesTMDB input[name="sortGenresTMDB"]:checked')).map(cb => cb.value);

        try {
            const duplicateCheck = await checkForDuplicates(payload);
            if (duplicateCheck.found) {
                displayMessage(addMessage, `Duplicate found by ${duplicateCheck.field} in project: ${duplicateCheck.project}. Addition denied.`, 'error');
            } else {
                await db.collection('movies').add(payload);
                displayMessage(addMessage, 'Content added successfully!', 'success');
                addMovieForm.reset();
                // Reset new sort checkboxes
                document.querySelectorAll('#sortVjsCheckboxesTMDB input').forEach(cb => cb.checked = false);
                document.querySelectorAll('#sortGenresCheckboxesTMDB input').forEach(cb => cb.checked = false);
            }
        } catch (error) {
            console.error("Error adding document:", error);
            displayMessage(addMessage, `Error: ${error.message}`, 'error');
        } finally {
            setLoading(addContentBtn, false);
        }
    });
    
    // --- Manual Add Form Logic (UPDATED) ---
    manualAddForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        setLoading(manualAddBtn, true);
        
        const manualTitle = document.getElementById('manualTitle').value.trim();
        const manualVjName = document.getElementById('manualVjName').value.trim();
        const referenceIdInput = document.getElementById('manualReferenceId').value.trim(); 
        const manualPosterUrl = document.getElementById('manualPosterUrl').value.trim();
        const manualBackdropUrl = document.getElementById('manualBackdropUrl').value.trim(); // Get backdrop URL

        if (!manualTitle || !manualVjName || !manualPosterUrl) { // Poster URL is now required
            displayMessage(manualAddMessage, 'Title, VJ Name, and Poster Image URL are required.', 'error');
            setLoading(manualAddBtn, false);
            return;
        }

        let tmdbId = null;
        let slug = generateSlug(manualTitle); // Default slug from title

        if (referenceIdInput) {
            // If referenceIdInput is provided, determine its type
            if (/^\d+$/.test(referenceIdInput)) {
                tmdbId = Number(referenceIdInput); // It's a numeric TMDB ID
                // slug remains generated from manualTitle for TMDB content
                displayMessage(manualAddMessage, `Warning: You entered a numeric ID. This will be saved as a TMDB ID, not a custom slug. Slug will be '${slug}'.`, 'warn');
            } else {
                // It's a custom text ID, so tmdbId is null, and slug is from this custom ID
                tmdbId = null;
                slug = generateSlug(referenceIdInput);
            }
        }
        // If referenceIdInput is empty, tmdbId remains null, slug from manualTitle (default)
        
        // Get selected genres for manual add
        const selectedGenres = Array.from(document.querySelectorAll('#manualGenreCheckboxes input[name="manualGenre"]:checked')).map(cb => cb.value);
        if(selectedGenres.length === 0) { // Optional: Require at least one genre
            displayMessage(manualAddMessage, 'Please select at least one genre.', 'error');
            setLoading(manualAddBtn, false);
            return;
        }

        let payload = {
            title: manualTitle,
            slug: slug, // This will be the custom slug if referenceIdInput was text
            overview: document.getElementById('manualOverview').value,
            posterUrl: manualPosterUrl,
            backdropUrl: manualBackdropUrl, // Add backdrop URL to payload
            vjName: manualVjName,
            tmdbId: tmdbId, // This will be the numeric TMDB ID or null
            genres: selectedGenres, // Add selected genres to payload
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            addedBy: auth.currentUser.email
        };

        const primaryType = document.getElementById('manualPrimaryContentType').value;
        if (primaryType === 'tv') {
            payload.contentType = 'tv';
            // For TV, 'type' will store the selected TV categories
            const selectedTypes = Array.from(document.querySelectorAll('#manualContentTypeCheckboxes input[name="manualContentType"]:checked')).map(cb => cb.value);
            if(selectedTypes.length === 0) {
                displayMessage(manualAddMessage, 'Please select at least one category for TV series.', 'error');
                setLoading(manualAddBtn, false);
                return;
            }
            payload.type = selectedTypes;
            try {
                const seriesDataValue = document.getElementById('manualSeriesData').value;
                if(!seriesDataValue) throw new Error("Series Data (JSON) cannot be empty for TV series.");
                payload.seriesInfo = JSON.parse(seriesDataValue);
            } catch (err) {
                displayMessage(manualAddMessage, err.message, 'error');
                setLoading(manualAddBtn, false);
                return;
            }
        } else {
            payload.contentType = 'movie';
            // For movies, 'type' will store the selected movie categories
            const selectedTypes = Array.from(document.querySelectorAll('#manualContentTypeCheckboxes input[name="manualContentType"]:checked')).map(cb => cb.value);
            if (selectedTypes.length === 0) {
                displayMessage(manualAddMessage, 'Please select at least one category for movies.', 'error');
                setLoading(manualAddBtn, false);
                return;
            }
            payload.type = selectedTypes;
            payload.videoUrl = document.getElementById('manualVideoSourceUrl').value;
        }

        // NEW: Collect values for sort_vjs and sort_genres for manual add
        payload.sort_vjs = Array.from(document.querySelectorAll('#sortVjsCheckboxesManual input[name="sortVjsManual"]:checked')).map(cb => cb.value);
        payload.sort_genres = Array.from(document.querySelectorAll('#sortGenresCheckboxesManual input[name="sortGenresManual"]:checked')).map(cb => cb.value);

        try {
            const duplicateCheck = await checkForDuplicates(payload);
            if (duplicateCheck.found) {
                displayMessage(manualAddMessage, `Duplicate found by ${duplicateCheck.field} in project: ${duplicateCheck.project}. Addition denied.`, 'error');
            } else {
                await db.collection('movies').add(payload);
                displayMessage(manualAddMessage, 'Content added successfully!', 'success');
                manualAddForm.reset();
                // After successful add, reset genre and new sort checkboxes
                document.querySelectorAll('#manualGenreCheckboxes input[name="manualGenre"]').forEach(cb => cb.checked = false);
                document.querySelectorAll('#sortVjsCheckboxesManual input').forEach(cb => cb.checked = false);
                document.querySelectorAll('#sortGenresCheckboxesManual input').forEach(cb => cb.checked = false);
            }
        } catch (error) {
            console.error("Error adding document manually:", error);
            displayMessage(manualAddMessage, `Error: ${error.message}`, 'error');
        } finally {
            setLoading(manualAddBtn, false);
        }
    });

    // --- Manage & Edit Content Logic (UPDATED) ---
    searchManageBtn.addEventListener('click', async () => {
        setLoading(searchManageBtn, true);
        manageSearchResults.innerHTML = '';
        selectedMoviesForDeletion.clear();
        confirmDeleteBtn.style.display = 'none';
        const term = document.getElementById('manageContentIdentifier').value.trim();
        if (!term) {
            displayMessage(manageMessage, 'Enter a name or ID to search.', 'error');
            setLoading(searchManageBtn, false);
            return;
        }
        
        try {
            let docs = [];
            const lowerCaseTerm = term.toLowerCase();
            
            // Search across all dbs
            for (const dbInfo of dbsToCheck) {
                const snapshot = await dbInfo.instance.collection('movies').get(); // Get all to filter by both tmdbId and title
                snapshot.forEach(doc => {
                    const data = doc.data();
                    // Check if TMDB ID matches (numeric search)
                    if (data.tmdbId && /^\d+$/.test(term) && data.tmdbId === Number(term)) {
                        docs.push({ id: doc.id, ...data, project: dbInfo.name });
                    } 
                    // Check if title or slug includes the term (case-insensitive)
                    else if (
                        (data.title && data.title.toLowerCase().includes(lowerCaseTerm)) || 
                        (data.slug && data.slug.toLowerCase().includes(lowerCaseTerm))
                    ) {
                        docs.push({ id: doc.id, ...data, project: dbInfo.name });
                    }
                });
            }

            // Remove duplicates if a doc exists in multiple dbs (shouldn't happen with proper ID management, but good for safety)
            const uniqueDocs = Array.from(new Map(docs.map(item => [item.id + item.project, item])).values());
            
            if(uniqueDocs.length === 0) {
                displayMessage(manageMessage, 'No content found matching your search.', 'info');
            } else {
                uniqueDocs.forEach(item => {
                    manageSearchResults.innerHTML += `
                        <div class="result-item">
                            <span><strong>${item.title}</strong> (ID: ${item.tmdbId || item.slug || 'N/A'}) - Type: ${item.contentType || 'N/A'} (Project: ${item.project})</span>
                            <div class="result-item-actions">
                                <button class="action-btn edit" data-id="${item.id}" data-project="${item.project}">Edit</button>
                                <button class="action-btn select-delete" data-id="${item.id}" data-project="${item.project}">Select</button>
                            </div>
                        </div>
                    `;
                });
                displayMessage(manageMessage, `Found ${uniqueDocs.length} item(s).`, 'success');
            }
        } catch (err) {
            console.error("Error searching content:", err);
            displayMessage(manageMessage, `Error searching content: ${err.message}`, 'error');
        } finally {
            setLoading(searchManageBtn, false);
        }
    });
    
    manageSearchResults.addEventListener('click', e => {
        if(e.target.matches('.select-delete')){
            const btn = e.target;
            const id = btn.dataset.id;
            const project = btn.dataset.project;
            const key = `${id}-${project}`; // Use a composite key for selection
            if(selectedMoviesForDeletion.has(key)){
                selectedMoviesForDeletion.delete(key);
                btn.classList.remove('selected');
                btn.textContent = 'Select';
            } else {
                selectedMoviesForDeletion.add(key);
                btn.classList.add('selected');
                btn.textContent = 'Selected';
            }
            confirmDeleteBtn.style.display = selectedMoviesForDeletion.size > 0 ? 'block' : 'none';
            confirmDeleteBtn.textContent = `Delete Selected (${selectedMoviesForDeletion.size})`;
        }
        if (e.target.matches('.action-btn.edit')) {
            const docId = e.target.dataset.id;
            const project = e.target.dataset.project;
            loadContentForEditing(docId, project);
        }
    });
    
    confirmDeleteBtn.addEventListener('click', async () => {
        if(confirm(`Are you sure you want to delete ${selectedMoviesForDeletion.size} item(s)? This action cannot be undone.`)){
            setLoading(confirmDeleteBtn, true);
            const deletePromises = [];
            selectedMoviesForDeletion.forEach(key => {
                const [id, project] = key.split('-');
                const targetDb = dbsToCheck.find(d => d.name === project)?.instance;
                if (targetDb) {
                    deletePromises.push(targetDb.collection('movies').doc(id).delete());
                } else {
                    console.warn(`Could not find database for project: ${project}`);
                }
            });

            try {
                await Promise.all(deletePromises);
                displayMessage(manageMessage, `Deleted ${selectedMoviesForDeletion.size} items successfully.`, 'success');
                manageSearchResults.innerHTML = ''; // Clear results after deletion
                confirmDeleteBtn.style.display = 'none';
                selectedMoviesForDeletion.clear();
            } catch(err){
                console.error("Error deleting content:", err);
                displayMessage(manageMessage, `Error deleting content: ${err.message}`, 'error');
            } finally {
                setLoading(confirmDeleteBtn, false);
            }
        }
    });

    // --- Edit Content Logic (UPDATED) ---
    async function loadContentForEditing(id, project) {
        try {
            const targetDb = dbsToCheck.find(d => d.name === project)?.instance || db; // Use primary db as fallback
            const docRef = targetDb.collection('movies').doc(id);
            const doc = await docRef.get();
            if (!doc.exists) {
                displayMessage(manageMessage, 'Content not found or already deleted.', 'error');
                return;
            }
            const data = doc.data();
            
            editContentForm.reset();
            document.getElementById('editDocId').value = doc.id;
            // Store the project ID where the document was found for update
            document.getElementById('editContentForm').dataset.projectId = project; 

            document.getElementById('editTitle').value = data.title || '';
            document.getElementById('editOverview').value = data.overview || '';
            document.getElementById('editPosterUrl').value = data.posterUrl || '';
            document.getElementById('editBackdropUrl').value = data.backdropUrl || ''; // Populate backdrop URL
            document.getElementById('editVjName').value = data.vjName || '';
            
            // Map the `movie` and `tv` values back to `latest_movies` and `latest_tv_shows` for display if needed
            // The actual stored `contentType` is still 'movie' or 'tv'.
            const primaryTypeSelector = document.getElementById('editPrimaryContentType');
            primaryTypeSelector.value = data.contentType === 'tv' ? 'tv' : 'movie';
            primaryTypeSelector.dispatchEvent(new Event('change')); // Trigger visibility logic

            // Populate "Reference ID" with tmdbId if present, otherwise with slug if it's not generated from title
            // If data.slug matches generateSlug(data.title), it means slug was from title, so don't show it as a custom ID.
            const isSlugFromTitle = generateSlug(data.title || '') === data.slug;
            document.getElementById('editReferenceId').value = data.tmdbId || (!isSlugFromTitle && data.slug ? data.slug : '');


            // Uncheck all category checkboxes first
            document.querySelectorAll('#editContentTypeCheckboxes input').forEach(cb => {
                cb.checked = false; 
            });

            // Set checked status based on `data.type`
            if (Array.isArray(data.type)) {
                data.type.forEach(typeValue => {
                    // Adjust typeValue for the admin panel's specific display values
                    let displayValue = typeValue;
                    if (typeValue === 'movie') displayValue = 'latest_movies';
                    if (typeValue === 'tv') displayValue = 'latest_tv_shows';
                    if (typeValue === 'popular') displayValue = 'latest_uploads'; // Map 'popular' back to 'latest_uploads'

                    const checkbox = document.querySelector(`#editContentTypeCheckboxes input[value="${displayValue}"]`);
                    if (checkbox) checkbox.checked = true;
                });
            }

            // Uncheck all genre checkboxes first
            document.querySelectorAll('#editGenreCheckboxes input[name="editGenre"]').forEach(cb => {
                cb.checked = false;
            });
            // Set checked status for genres based on `data.genres`
            if (Array.isArray(data.genres)) {
                data.genres.forEach(genreValue => {
                    const checkbox = document.querySelector(`#editGenreCheckboxes input[value="${genreValue}"]`);
                    if (checkbox) checkbox.checked = true;
                });
            }
            
            // NEW: Populate sort_vjs and sort_genres checkboxes
            populateCheckboxes('sortVjsCheckboxesEdit', 'sortVjsEdit', VJ_LIST, data.sort_vjs || []);
            populateCheckboxes('sortGenresCheckboxesEdit', 'sortGenresEdit', GENRE_LIST, data.sort_genres || []);
            
            if (data.contentType === 'movie') {
                document.getElementById('editVideoSourceUrl').value = data.videoUrl || '';
            } else if (data.contentType === 'tv') {
                document.getElementById('editSeriesData').value = data.seriesInfo ? JSON.stringify(data.seriesInfo, null, 2) : '';
            }

            navigateToPage('editContentPage');
        } catch (err) {
            console.error("Error loading content for editing:", err);
            displayMessage(manageMessage, `Error loading content: ${err.message}`, 'error');
        }
    }

    editContentForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        setLoading(updateContentBtn, true);
        const docId = document.getElementById('editDocId').value;
        const targetProjectId = e.target.dataset.projectId; // Get the project ID where the doc was found
        const targetDb = dbsToCheck.find(d => d.name === targetProjectId)?.instance || db; // Use the original DB, fallback to primary

        if (!docId) {
            displayMessage(editMessage, 'No document ID found. Cannot update.', 'error');
            setLoading(updateContentBtn, false);
            return;
        }
        const editTitle = document.getElementById('editTitle').value.trim();
        const editVjName = document.getElementById('editVjName').value.trim();
        const referenceIdInput = document.getElementById('editReferenceId').value.trim(); 
        const editPosterUrl = document.getElementById('editPosterUrl').value.trim();
        const editBackdropUrl = document.getElementById('editBackdropUrl').value.trim(); // Get backdrop URL

        if (!editTitle || !editVjName || !editPosterUrl) { // Poster URL is now required
            displayMessage(editMessage, 'Title, VJ Name, and Poster Image URL are required.', 'error');
            setLoading(updateContentBtn, false);
            return;
        }

        let tmdbId = null;
        let slug = generateSlug(editTitle); // Default slug from title

        if(referenceIdInput) {
            if(/^\d+$/.test(referenceIdInput)) {
                tmdbId = Number(referenceIdInput);
                // slug remains generated from editTitle for TMDB content
            } else {
                tmdbId = null; // It's a custom entry
                slug = generateSlug(referenceIdInput); // For custom content, slug is based on the reference ID field
            }
        }
        // If referenceIdInput is empty, tmdbId is null, slug from editTitle (default)
            
        // Get selected genres from the edit form
        const selectedGenres = Array.from(document.querySelectorAll('#editGenreCheckboxes input[name="editGenre"]:checked')).map(cb => cb.value);
        if(selectedGenres.length === 0) { // Optional: Require at least one genre for edit
            displayMessage(editMessage, 'Please select at least one genre.', 'error');
            setLoading(updateContentBtn, false);
            return;
        }

        let payload = {
            title: editTitle,
            slug: slug,
            overview: document.getElementById('editOverview').value,
            posterUrl: editPosterUrl,
            backdropUrl: editBackdropUrl, // Add backdrop URL to payload
            vjName: editVjName,
            tmdbId: tmdbId,
            genres: selectedGenres, // Add selected genres to payload
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        };

        const primaryType = document.getElementById('editPrimaryContentType').value;
        if (primaryType === 'tv') {
            payload.contentType = 'tv';
            // For TV, 'type' will store the selected TV categories
            const selectedTypes = Array.from(document.querySelectorAll('#editContentTypeCheckboxes input[name="editContentType"]:checked')).map(cb => {
                // Map the displayed values back to original stored values
                if (cb.value === 'latest_movies') return 'movie';
                if (cb.value === 'latest_tv_shows') return 'tv';
                if (cb.value === 'latest_uploads') return 'popular';
                return cb.value; // Return as is for other values
            });
            if (selectedTypes.length === 0) {
                    displayMessage(editMessage, 'Please select at least one category for TV series.', 'error');
                    setLoading(updateContentBtn, false);
                    return;
            }
            payload.type = selectedTypes;
            try {
                const seriesDataValue = document.getElementById('editSeriesData').value;
                if(!seriesDataValue) throw new Error("Series Data (JSON) cannot be empty for TV series.");
                payload.seriesInfo = JSON.parse(seriesDataValue);
                payload.videoUrl = firebase.firestore.FieldValue.delete(); // Ensure videoUrl is removed for TV
            } catch (err) {
                displayMessage(editMessage, err.message, 'error');
                setLoading(updateContentBtn, false);
                return;
            }
        } else { 
            payload.contentType = 'movie';
            // For movies, 'type' will store the selected movie categories
            const selectedTypes = Array.from(document.querySelectorAll('#editContentTypeCheckboxes input[name="editContentType"]:checked')).map(cb => {
                // Map the displayed values back to original stored values
                if (cb.value === 'latest_movies') return 'movie';
                if (cb.value === 'latest_tv_shows') return 'tv';
                if (cb.value === 'latest_uploads') return 'popular';
                return cb.value; // Return as is for other values
            });
            if (selectedTypes.length === 0) {
                    displayMessage(editMessage, 'Please select at least one category for movies.', 'error');
                    setLoading(updateContentBtn, false);
                    return;
            }
            payload.type = selectedTypes;
            payload.videoUrl = document.getElementById('editVideoSourceUrl').value;
            payload.seriesInfo = firebase.firestore.FieldValue.delete(); // Ensure seriesInfo is removed for movies
        }
        
        // NEW: Collect values for sort_vjs and sort_genres from the edit form
        payload.sort_vjs = Array.from(document.querySelectorAll('#sortVjsCheckboxesEdit input[name="sortVjsEdit"]:checked')).map(cb => cb.value);
        payload.sort_genres = Array.from(document.querySelectorAll('#sortGenresCheckboxesEdit input[name="sortGenresEdit"]:checked')).map(cb => cb.value);

        try {
            // Pass the docId AND the project ID for exclusion during duplicate check
            const duplicateCheck = await checkForDuplicates(payload, docId, targetProjectId); 
            if (duplicateCheck.found) {
                displayMessage(editMessage, `Update failed. Another entry exists with this ${duplicateCheck.field} in project: ${duplicateCheck.project}.`, 'error');
            } else {
                await targetDb.collection('movies').doc(docId).update(payload); // Update in the specific DB
                displayMessage(editMessage, 'Content updated successfully!', 'success');
                setTimeout(() => navigateToPage('allContentPage'), 2000);
            }
        } catch (error) {
            console.error("Update Error:", error);
            displayMessage(editMessage, `Update Error: ${error.message}`, 'error');
        } finally {
            setLoading(updateContentBtn, false);
        }
    });

    cancelEditBtn.addEventListener('click', () => { navigateToPage('allContentPage'); }); 

    // --- All Content Page Logic ---
    async function displayAllContent() {
        allContentContainer.innerHTML = '<div class="message info" style="display:block;">Loading all content...</div>';
        selectedAllContentForDeletion.clear();
        updateDeleteSelectedButton(); 
        
        const filterValue = allContentFilter.value;
        const filterText = allContentFilter.options[allContentFilter.selectedIndex].text;
        
        // Adjust button text and behavior based on filter
        if (filterValue === 'all' || filterValue === 'latest_movies' || filterValue === 'latest_tv_shows') {
            deleteSelectedAllContentBtn.textContent = `Delete Selected Content (${selectedAllContentForDeletion.size})`;
            deleteSelectedAllContentBtn.classList.remove('remove-from-category-mode'); // Optional: add a class for styling
            deleteSelectedAllContentBtn.dataset.deleteMode = 'permanent';
        } else {
            deleteSelectedAllContentBtn.textContent = `Remove Selected from ${filterText} (${selectedAllContentForDeletion.size})`;
            deleteSelectedAllContentBtn.classList.add('remove-from-category-mode'); // Optional: add a class for styling
            deleteSelectedAllContentBtn.dataset.deleteMode = 'category-removal';
        }

        try {
            let docsToDisplay = [];

            for (const dbInfo of dbsToCheck) {
                let query = dbInfo.instance.collection('movies').orderBy('createdAt', 'desc');
                
                if (filterValue !== 'all') {
                    // For 'latest_movies' or 'latest_tv_shows' primary content type filters
                    if (filterValue === 'latest_movies') {
                        query = query.where('contentType', '==', 'movie');
                    } else if (filterValue === 'latest_tv_shows') {
                        query = query.where('contentType', '==', 'tv');
                    }
                    // For specific categories (e.g., 'animation', 'horror'), query the 'type' array
                    else {
                        // Map filterValue back to the actual stored type value if it's a renamed one
                        let actualFilterValue = filterValue;
                        if (filterValue === 'latest_movies') actualFilterValue = 'movie';
                        if (filterValue === 'latest_tv_shows') actualFilterValue = 'tv';
                        if (filterValue === 'latest_uploads') actualFilterValue = 'popular';

                        query = query.where('type', 'array-contains', actualFilterValue);
                    }
                }
                const snapshot = await query.get();
                snapshot.forEach(doc => {
                    docsToDisplay.push({ id: doc.id, ...doc.data(), project: dbInfo.name });
                });
            }

            // Optional: Deduplicate if the same movie exists across multiple dbs (shouldn't happen with proper ID management, but good for safety)
            // For simplicity, we'll show all found entries for now, with their project name.
            
            if (docsToDisplay.length === 0) {
                allContentContainer.innerHTML = '';
                displayMessage(allContentMessage, 'No content found.', 'info');
                return;
            }
            
            allContentContainer.innerHTML = '';
            docsToDisplay.forEach(item => {
                const imageUrl = item.posterUrl || 'https://placehold.co/500x750/333/eee?text=No+Poster'; 
                const title = item.title || 'Untitled';
                const vjName = item.vjName || 'Unknown VJ';
                // Display TMDB ID or custom slug
                const contentId = item.tmdbId || item.slug || 'N/A'; 

                // Determine button text based on filterType
                const individualButtonText = (filterValue === 'all' || filterValue === 'latest_movies' || filterValue === 'latest_tv_shows') ? 'Delete' : 'Remove from Category';
                const individualButtonClass = (filterValue === 'all' || filterValue === 'latest_movies' || filterValue === 'latest_tv_shows') ? 'delete' : 'remove-from-category';

                const cardHtml = `
                    <div class="content-card">
                        <input type="checkbox" class="select-card-checkbox" data-id="${item.id}" data-project="${item.project}">
                        <img src="${imageUrl}" alt="${title}" onerror="this.onerror=null; this.src='/Upload/Logo.png';">
                        <div class="content-card-content">
                            <h3>${title}</h3>
                            <p class="vj-name">VJ: ${vjName}</p>
                            <p class="content-id-display">ID: ${contentId}</p>
                            <p class="content-project-display">Project: ${item.project}</p>
                            <div class="content-card-actions">
                                <button class="action-btn edit" data-id="${item.id}" data-project="${item.project}">Edit</button>
                                <button class="action-btn ${individualButtonClass}" data-id="${item.id}" data-project="${item.project}">${individualButtonText}</button>
                            </div>
                        </div>
                    </div>
                `;
                allContentContainer.insertAdjacentHTML('beforeend', cardHtml);
            });
            displayMessage(allContentMessage, `Found ${docsToDisplay.length} item(s).`, 'success');

        } catch (err) {
            console.error("Error displaying all content:", err);
            allContentContainer.innerHTML = '';
            displayMessage(allContentMessage, `Error: ${err.message}`, 'error');
        }
    }

    function updateDeleteSelectedButton() {
        selectedAllContentCount.textContent = selectedAllContentForDeletion.size;
        deleteSelectedAllContentBtn.style.display = selectedAllContentForDeletion.size > 0 ? 'block' : 'none';
        
        // Update the text on the main button as well
        const filterValue = allContentFilter.value;
        const filterText = allContentFilter.options[allContentFilter.selectedIndex].text;
        if (filterValue === 'all' || filterValue === 'latest_movies' || filterValue === 'latest_tv_shows') {
            deleteSelectedAllContentBtn.textContent = `Delete Selected Content (${selectedAllContentForDeletion.size})`;
        } else {
            deleteSelectedAllContentBtn.textContent = `Remove Selected from ${filterText} (${selectedAllContentForDeletion.size})`;
        }
    }

    allContentFilter.addEventListener('change', displayAllContent);

    // Function to remove a specific category from a content item
    async function removeContentFromCategory(docId, project, categoryToRemove) {
        const targetDb = dbsToCheck.find(d => d.name === project)?.instance;
        if (!targetDb) {
            throw new Error(`Database instance not found for project: ${project}`);
        }

        const docRef = targetDb.collection('movies').doc(docId);
        const docSnap = await docRef.get();

        if (docSnap.exists) {
            const currentTypes = docSnap.data().type || [];
            // Map the categoryToRemove back to its original stored value if it was a renamed display value
            let actualCategoryToRemove = categoryToRemove;
            if (categoryToRemove === 'latest_movies') actualCategoryToRemove = 'movie';
            if (categoryToRemove === 'latest_tv_shows') actualCategoryToRemove = 'tv';
            if (categoryToRemove === 'latest_uploads') actualCategoryToRemove = 'popular';

            const updatedTypes = currentTypes.filter(type => type !== actualCategoryToRemove);
            
            await docRef.update({
                type: updatedTypes,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            return true;
        }
        return false;
    }

    allContentContainer.addEventListener('click', async e => {
        const target = e.target;
        // For checkbox or buttons, get the docId and project from dataset
        const cardElement = target.closest('.content-card');
        const docId = cardElement?.querySelector('.select-card-checkbox')?.dataset.id || target.dataset.id;
        const project = cardElement?.querySelector('.select-card-checkbox')?.dataset.project || target.dataset.project;
        
        if (!docId || !project) return; // Exit if no id or project found

        const targetDb = dbsToCheck.find(d => d.name === project)?.instance;
        if (!targetDb) {
            console.error(`Database instance not found for project: ${project}`);
            displayMessage(allContentMessage, `Error: Database for project '${project}' not found.`, 'error');
            return;
        }

        const filterValue = allContentFilter.value;
        const filterText = allContentFilter.options[allContentFilter.selectedIndex].text;

        if (target.matches('.select-card-checkbox')) {
            const key = `${docId}-${project}`;
            if (target.checked) {
                selectedAllContentForDeletion.add(key);
            } else {
                selectedAllContentForDeletion.delete(key);
            }
            updateDeleteSelectedButton();
        } else if (target.matches('.action-btn.edit')) {
            loadContentForEditing(docId, project);
        } else if (target.matches('.action-btn.delete')) { // This is for permanent delete
            if (confirm(`Are you sure you want to delete this content permanently from ${project}? This cannot be undone.`)) {
                setLoading(target, true);
                try {
                    await targetDb.collection('movies').doc(docId).delete();
                    displayMessage(allContentMessage, 'Content deleted successfully!', 'success');
                    const keyToDelete = `${docId}-${project}`;
                    selectedAllContentForDeletion.delete(keyToDelete); 
                    updateDeleteSelectedButton();
                    displayAllContent(); 
                } catch (err) {
                    console.error("Error deleting content:", err);
                    displayMessage(allContentMessage, `Error deleting content: ${err.message}`, 'error');
                } finally {
                    setLoading(target, false);
                }
            }
        } else if (target.matches('.action-btn.remove-from-category')) { // This is for category removal
            if (confirm(`Are you sure you want to remove this content from the "${filterText}" category in ${project}? It will not be permanently deleted.`)) {
                setLoading(target, true);
                try {
                    const success = await removeContentFromCategory(docId, project, filterValue);
                    if (success) {
                        displayMessage(allContentMessage, `Content removed from "${filterText}" category successfully!`, 'success');
                        const keyToDelete = `${docId}-${project}`; // Remove from current selection as it's no longer in this view
                        selectedAllContentForDeletion.delete(keyToDelete); 
                        updateDeleteSelectedButton();
                        displayAllContent(); // Re-display to update list
                    } else {
                        displayMessage(allContentMessage, 'Failed to remove content from category: Document not found.', 'error');
                    }
                } catch (err) {
                    console.error("Error removing from category:", err);
                    displayMessage(allContentMessage, `Error removing from category: ${err.message}`, 'error');
                } finally {
                    setLoading(target, false);
                }
            }
        }
    });

    deleteSelectedAllContentBtn.addEventListener('click', async () => {
        if (selectedAllContentForDeletion.size === 0) {
            displayMessage(allContentMessage, 'No content selected for action.', 'info');
            return;
        }
        
        const filterValue = allContentFilter.value;
        const filterText = allContentFilter.options[allContentFilter.selectedIndex].text;
        const isPermanentDelete = (filterValue === 'all' || filterValue === 'latest_movies' || filterValue === 'latest_tv_shows');

        let confirmationMessage;
        let successMessage;
        let errorMessage;
        let actionPromises = [];

        if (isPermanentDelete) {
            confirmationMessage = `Are you sure you want to delete ${selectedAllContentForDeletion.size} item(s) permanently? This action cannot be undone.`;
            successMessage = `Deleted ${selectedAllContentForDeletion.size} items successfully.`;
            errorMessage = `Error deleting selected content: `;
        } else {
            confirmationMessage = `Are you sure you want to remove ${selectedAllContentForDeletion.size} item(s) from the "${filterText}" category? They will not be permanently deleted.`;
            successMessage = `Removed ${selectedAllContentForDeletion.size} items from "${filterText}" category successfully.`;
            errorMessage = `Error removing selected content from category: `;
        }

        if (confirm(confirmationMessage)) {
            setLoading(deleteSelectedAllContentBtn, true);
            
            selectedAllContentForDeletion.forEach(key => {
                const [id, project] = key.split('-');
                const targetDb = dbsToCheck.find(d => d.name === project)?.instance;
                if (targetDb) {
                    if (isPermanentDelete) {
                        actionPromises.push(targetDb.collection('movies').doc(id).delete());
                    } else {
                        actionPromises.push(removeContentFromCategory(id, project, filterValue));
                    }
                } else {
                    console.warn(`Could not find database for project: ${project}`);
                }
            });

            try {
                await Promise.all(actionPromises);
                displayMessage(allContentMessage, successMessage, 'success');
                selectedAllContentForDeletion.clear(); 
                updateDeleteSelectedButton();
                displayAllContent(); 
            } catch (err) {
                console.error(errorMessage, err);
                displayMessage(allContentMessage, `${errorMessage}${err.message}`, 'error');
            } finally {
                    setLoading(deleteSelectedAllContentBtn, false);
            }
        }
    });


    // --- Banner logic ---
    async function displayAllBanners() {
        allBannersContainer.innerHTML = '<div class="message info" style="display:block;">Loading banners...</div>';
        try {
            const snapshot = await db.collection('banners').orderBy('updatedAt', 'desc').limit(10).get();
            if (snapshot.empty) {
                allBannersContainer.innerHTML = '';
                displayMessage(viewBannersMessage, 'No banners found. Add one from the "Add/Edit Banner" tab.', 'info');
                return;
            }
            allBannersContainer.innerHTML = '';
            snapshot.forEach(doc => {
                const banner = doc.data();
                const card = `
                    <div class="banner-card">
                        <img src="${banner.imageUrl}" alt="${banner.title}" onerror="this.src='https://placehold.co/500x300/333/eee?text=No+Image';">
                        <div class="banner-card-content">
                            <h3>${banner.title}</h3>
                            <p>${(banner.description || 'No description available.').substring(0, 100)}...</p>
                            <div class="banner-card-actions">
                                <button class="action-btn edit" data-id="${doc.id}">Edit</button>
                                <button class="action-btn delete" data-id="${doc.id}">Delete</button>
                            </div>
                        </div>
                    </div>
                `;
                allBannersContainer.insertAdjacentHTML('beforeend', card);
            });
            displayMessage(viewBannersMessage, `Found ${snapshot.size} banner(s).`, 'success');
        } catch (err) {
            console.error("Error displaying banners:", err);
            allBannersContainer.innerHTML = '';
            displayMessage(viewBannersMessage, `Error: ${err.message}`, 'error');
        }
    }

    bannerNavTabs.addEventListener('click', e => {
        if (e.target.matches('.banner-tab-link')) {
            const tabId = e.target.dataset.tab;
            document.querySelectorAll('.banner-tab-link').forEach(t => t.classList.remove('active'));
            e.target.classList.add('active');
            document.querySelectorAll('.banner-tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
            if (tabId === 'viewBannersTab') {
                displayAllBanners();
            }
        }
    });

    allBannersContainer.addEventListener('click', async e => {
        const target = e.target;
        if (target.matches('.action-btn.delete')) {
            const docId = target.dataset.id;
            if (confirm('Are you sure you want to delete this banner permanently?')) {
                setLoading(target, true);
                try {
                    await db.collection('banners').doc(docId).delete();
                    displayMessage(viewBannersMessage, 'Banner deleted successfully!', 'success');
                    await displayAllBanners();
                } catch (err) {
                    console.error("Error deleting banner:", err);
                    displayMessage(viewBannersMessage, `Error deleting banner: ${err.message}`, 'error');
                    setLoading(target, false);
                }
            }
        }
        if (target.matches('.action-btn.edit')) {
            await loadBannerForEditing(target.dataset.id);
        }
    });

    addEditBannerForm.addEventListener('submit', async e => {
        e.preventDefault();
        setLoading(saveBannerBtn, true);
        const id = bannerDocId.value;
        const data = {
            title: document.getElementById('bannerTitle').value.trim(),
            imageUrl: document.getElementById('bannerImageUrl').value,
            description: document.getElementById('bannerDescription').value,
            link: document.getElementById('bannerLink').value,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        };

        if (!data.title || !data.imageUrl || !data.link) {
            displayMessage(addBannerMessage, 'Title, Image URL, and Link are required for banners.', 'error');
            setLoading(saveBannerBtn, false);
            return;
        }

        try {
            if (id) {
                await db.collection('banners').doc(id).update(data);
            } else {
                await db.collection('banners').add({ ...data, createdAt: firebase.firestore.FieldValue.serverTimestamp() });
            }
            displayMessage(addBannerMessage, 'Banner saved successfully!', 'success');
            resetBannerForm();
            document.querySelector('.banner-tab-link[data-tab="viewBannersTab"]').click(); 
        } catch (err) {
            console.error("Error saving banner:", err);
            displayMessage(addBannerMessage, `Error saving banner: ${err.message}`, 'error');
        } finally {
            setLoading(saveBannerBtn, false);
        }
    });

    function resetBannerForm() {
        addEditBannerForm.reset();
        bannerDocId.value = '';
        bannerFormTitle.textContent = 'Add New Banner';
        saveBannerBtn.textContent = 'Save Banner';
        cancelEditBannerBtn.style.display = 'none';
        displayMessage(addBannerMessage, '', ''); 
    }
    cancelEditBannerBtn.addEventListener('click', resetBannerForm);

    async function loadBannerForEditing(id) {
        try {
            const doc = await db.collection('banners').doc(id).get();
            if (doc.exists) {
                const d = doc.data();
                bannerDocId.value = id;
                document.getElementById('bannerTitle').value = d.title || '';
                document.getElementById('bannerImageUrl').value = d.imageUrl || '';
                document.getElementById('bannerDescription').value = d.description || '';
                document.getElementById('bannerLink').value = d.link || '';
                bannerFormTitle.textContent = 'Editing Banner';
                saveBannerBtn.textContent = 'Update Banner';
                cancelEditBannerBtn.style.display = 'inline-block';
                document.querySelector('.banner-tab-link[data-tab="addBannerTab"]').click(); 
                window.scrollTo(0, 0);
            } else {
                displayMessage(addBannerMessage, 'Banner not found.', 'error');
            }
        } catch(err) {
            console.error("Error loading banner for editing:", err);
            displayMessage(addBannerMessage, 'Could not load banner for editing.', 'error');
        }
    }


    // --- User Management Logic ---
    userSearchBtn.addEventListener('click', async () => {
        const emailToSearch = userSearchEmailInput.value.trim();
        if (!emailToSearch) {
            displayUserMessage('Please enter an email to search.', 'error');
            return;
        }
        
        hideUserMessage();
        userEditFormSection.classList.add('hidden');
        userSearchBtn.disabled = true;
        userSearchBtn.textContent = 'Searching...';

        try {
            const usersRef = db.collection("users");
            const q = usersRef.where("email", "==", emailToSearch);
            const querySnapshot = await q.get();

            if (querySnapshot.empty) {
                displayUserMessage(`No user found with email: ${emailToSearch}. You can create a new document.`, 'info'); 
                clearUserForm();
                userEditEmailInput.value = emailToSearch;
                userFormTitle.textContent = "Create New User Document";
                userDocIdInput.value = "Will be auto-generated upon creation";
                userUpdateBtn.classList.add('hidden');
                userCreateBtn.classList.remove('hidden');
            } else {
                const userDoc = querySnapshot.docs[0];
                const userData = userDoc.data();
                displayUserMessage('User found. You can now edit the details below.', 'success');
                userDocIdInput.value = userDoc.id;
                userEditNameInput.value = userData.name || '';
                userEditEmailInput.value = userData.email || '';
                userEditActivatedSelect.value = userData.activated ? 'true' : 'false';
                userEditExpiresAtInput.value = formatTimestampForInput(userData.expiresAt);
                userFormTitle.textContent = "Edit User Document";
                userCreateBtn.classList.add('hidden');
                userUpdateBtn.classList.remove('hidden');
            }
            userEditFormSection.classList.remove('hidden');
            userFormDivider.classList.remove('hidden');
        } catch (error) {
            console.error("Error searching user: ", error);
            displayUserMessage(`An error occurred while searching: ${error.message}`, 'error');
        } finally {
            userSearchBtn.disabled = false;
            userSearchBtn.textContent = 'Search User';
        }
    });

    userUpdateBtn.addEventListener('click', async () => {
        const userId = userDocIdInput.value;
        if (!userId || userId === "Will be auto-generated upon creation") {
            displayUserMessage('No user document ID found. Please search for a user or use "Create New Document".', 'error');
            return;
        }
        userUpdateBtn.disabled = true;
        userUpdateBtn.textContent = 'Updating...';
        try {
            const userDocRef = db.collection("users").doc(userId);
            const dateValue = userEditExpiresAtInput.value ? new Date(userEditExpiresAtInput.value) : null;

            await userDocRef.update({
                name: userEditNameInput.value,
                email: userEditEmailInput.value,
                activated: userEditActivatedSelect.value === 'true',
                expiresAt: dateValue ? firebase.firestore.Timestamp.fromDate(dateValue) : null 
            });
            displayUserMessage('User document updated successfully!', 'success');
        } catch (error) {
            console.error("Error updating user document: ", error);
            displayUserMessage(`Failed to update document: ${error.message}`, 'error');
        } finally {
            userUpdateBtn.disabled = false;
            userUpdateBtn.textContent = 'Update Document';
        }
    });

    userCreateBtn.addEventListener('click', async () => {
        const email = userEditEmailInput.value.trim();
        const name = userEditNameInput.value.trim();
        if (!email || !name) {
            displayUserMessage('Email and Name are required to create a new document.', 'error');
            return;
        }
        userCreateBtn.disabled = true;
        userCreateBtn.textContent = 'Creating...';
        try {
            const newDocRef = db.collection("users").doc(); 
            const dateValue = userEditExpiresAtInput.value ? new Date(userEditExpiresAtInput.value) : null;

            await newDocRef.set({
                name: name,
                email: email,
                phone: "", 
                profileImage: "",
                activated: userEditActivatedSelect.value === 'true',
                expiresAt: dateValue ? firebase.firestore.Timestamp.fromDate(dateValue) : null,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                deleted: false
            });
            userDocIdInput.value = newDocRef.id;
            displayUserMessage(`New document created successfully with ID: ${newDocRef.id}`, 'success');
            userCreateBtn.classList.add('hidden');
            userUpdateBtn.classList.remove('hidden');
            userFormTitle.textContent = "Edit User Document"; 
        } catch (error) {
            console.error("Error creating user document: ", error);
            displayUserMessage(`Failed to create document: ${error.message}`, 'error');
        } finally {
            userCreateBtn.disabled = false;
            userCreateBtn.textContent = 'Create New Document';
        }
    });
});
    </script>

</body>
</html>
